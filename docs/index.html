<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeurIPS Twin Survey 2025 - Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            background: #ffffff;
            color: #000;
            line-height: 1.6;
            padding: 40px 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #000;
        }

        .authors {
            font-size: 1.1em;
            margin-bottom: 10px;
            font-style: italic;
        }

        .affiliation {
            font-size: 0.95em;
            color: #333;
            margin-bottom: 20px;
        }

        .abstract {
            max-width: 900px;
            margin: 20px auto;
            text-align: justify;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .abstract strong {
            font-weight: bold;
        }

        h2 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 40px 0 20px 0;
            color: #000;
        }

        .section {
            margin: 40px 0;
        }

        .compass-section {
            margin: 40px 0;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 30px auto;
            aspect-ratio: 1 / 1;
        }

        .pie-charts-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin: 40px 0;
        }

        .pie-chart-wrapper {
            background: #f9f9f9;
            padding: 40px;
            border: 1px solid #ddd;
        }

        .pie-chart-wrapper h3 {
            font-size: 1em;
            margin-bottom: 15px;
            text-align: center;
            color: #000;
        }

        .pie-chart-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
        }

        .figure-caption {
            text-align: center;
            font-size: 0.9em;
            margin: 15px auto 0;
            max-width: 800px;
            color: #333;
        }

        .figure-caption strong {
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: #666;
        }

        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            text-align: center;
            font-size: 0.85em;
            color: #666;
        }

        footer a {
            color: #000;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NeurIPS Twin Survey 2025: Understanding AI Researcher Perspectives</h1>
            <div class="authors">Anonymous Authors</div>
            <div class="affiliation">NeurIPS 2025</div>
            <div class="abstract">
                <strong>Abstract.</strong> We present an analysis of survey data (N=335) collected from AI researchers
                attending NeurIPS 2025. The survey captures perspectives on AGI timelines, AI safety concerns,
                workplace preferences, and research methodologies. We visualize the relationship between beliefs
                using two-dimensional political compasses, revealing distinct clusters of researcher perspectives.
            </div>
        </header>

        <div id="loading" class="loading">Loading survey data...</div>

        <div id="content" style="display: none;">
            <section class="section compass-section">
                <h2>1. Political Compass: AGI Beliefs vs. Safety Priorities</h2>
                <div class="chart-container">
                    <canvas id="compassChart1"></canvas>
                </div>
                <div class="figure-caption">
                    <strong>Figure 1:</strong> Political compass mapping AI researcher positions based on AGI timeline
                    beliefs (X-axis: "I believe AGI is likely within the next 10 years", 1-5 Likert scale) and AI safety
                    priorities (Y-axis: "We should slow down AI progress until safety is better understood", inverted 1-5 scale).
                    Each large point represents the average position of researchers sharing a categorical preference.
                    Small colored dots represent individual respondents (with jitter to prevent overlap), colored based on
                    their position. Color indicates safety priority through a blue-white-red gradient (blue = move fast,
                    red = prioritize safety). Opacity encodes AGI timeline belief strength (faint = skeptical, solid = believer).
                    Hover over a category to highlight its respondents with connecting lines.
                </div>
            </section>

            <section class="section">
                <h2>2. Categorical Response Distributions</h2>
                <div class="pie-charts-container">
                    <div class="pie-chart-wrapper">
                        <h3>Dream Dinner Companion</h3>
                        <div class="pie-chart-container">
                            <canvas id="dinnerPieChart"></canvas>
                        </div>
                        <p style="font-size: 0.85em; text-align: center; margin-top: 10px; color: #666;">
                            "Who would you most want to have dinner with?"
                        </p>
                    </div>
                    <div class="pie-chart-wrapper">
                        <h3>Preferred Workplace</h3>
                        <div class="pie-chart-container">
                            <canvas id="workplacePieChart"></canvas>
                        </div>
                        <p style="font-size: 0.85em; text-align: center; margin-top: 10px; color: #666;">
                            "I would most want to work at:"
                        </p>
                    </div>
                    <div class="pie-chart-wrapper">
                        <h3>Favorite ML Podcast</h3>
                        <div class="pie-chart-container">
                            <canvas id="podcastPieChart"></canvas>
                        </div>
                        <p style="font-size: 0.85em; text-align: center; margin-top: 10px; color: #666;">
                            "What is your favorite ML related podcast?"
                        </p>
                    </div>
                </div>
            </section>

            <section class="section compass-section">
                <h2>3. Political Compass: Prototype vs. Paper & Creativity vs. Rigor</h2>
                <div class="chart-container">
                    <canvas id="compassChart2"></canvas>
                </div>
                <div class="figure-caption">
                    <strong>Figure 2:</strong> Second political compass showing the relationship between preference for
                    prototypes vs. papers (X-axis: "I'd rather build a working prototype than write a perfect paper", 1-5 scale)
                    and belief in creativity vs. rigor (Y-axis: "I believe creativity is more important than rigor in research", 1-5 scale).
                    Each large point represents the average position of researchers sharing a categorical preference.
                    Small colored dots represent individual respondents (with jitter to prevent overlap), colored based on
                    their position. Color encodes Y-axis position (blue = rigor-focused, red = creativity-focused). Opacity
                    encodes X-axis belief strength (faint = prefer papers, solid = prefer prototypes). Hover over a category
                    to highlight its respondents with connecting lines.
                </div>
            </section>
        </div>

        <footer>
            <p>NeurIPS Twin Survey 2025 | <a href="https://github.com/mathyouf/neurips2025">View on GitHub</a></p>
        </footer>
    </div>

    <script>
        let surveyData = null;
        let processedData = {
            dinner: [],
            workplace: [],
            podcast: []
        };
        let processedData2 = {
            dinner: [],
            workplace: [],
            podcast: []
        };
        const collisionThreshold = 0.2;
        let visibleLabelIndices1 = new Set();
        let visibleLabelIndices2 = new Set();
        let hoveredCategory1 = null;
        let hoveredCategory2 = null;
        let chart1Instance = null;
        let chart2Instance = null;
        let hoveredCategoryPoint1 = null;  // Stores {x, y, matches: [indices]}
        let hoveredCategoryPoint2 = null;  // Stores {x, y, matches: [indices]}

        Papa.parse('neuripstwin7.csv', {
            download: true,
            header: true,
            complete: function(results) {
                surveyData = results.data.filter(row => row.Timestamp && row.Timestamp.trim() !== '');
                console.log('Loaded', surveyData.length, 'responses');

                // Process data for first compass (AGI vs Safety)
                processedData.dinner = processCategory(
                    'Who would you most want to have dinner with?',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    3
                );
                processedData.workplace = processCategory(
                    'I would most want to work at:',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    3
                );
                processedData.podcast = processCategory(
                    'What is your favorite ML related podcast?',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    5
                );

                // Process data for second compass (Prototype vs Creativity)
                processedData2.dinner = processCategory(
                    'Who would you most want to have dinner with?',
                    'I’d rather build a working prototype than write a perfect paper.',
                    'I believe creativity is more important than rigor in research.',
                    3
                );
                processedData2.workplace = processCategory(
                    'I would most want to work at:',
                    'I’d rather build a working prototype than write a perfect paper.',
                    'I believe creativity is more important than rigor in research.',
                    3
                );
                processedData2.podcast = processCategory(
                    'What is your favorite ML related podcast?',
                    'I’d rather build a working prototype than write a perfect paper.',
                    'I believe creativity is more important than rigor in research.',
                    5
                );

                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                console.log('First compass data points:',
                    processedData.dinner.length + processedData.workplace.length + processedData.podcast.length);
                console.log('Second compass data points:',
                    processedData2.dinner.length + processedData2.workplace.length + processedData2.podcast.length);
                console.log('Sample from second compass:', processedData2.dinner.slice(0, 3));

                createCompassChart1();
                createCompassChart2();
                createPieCharts();
            },
            error: function(error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 'Error loading data. Please check the console.';
            }
        });

        // Plugin to draw connecting lines from category points to individual respondents
        const connectionLinesPlugin = {
            id: 'connectionLines',
            beforeDatasetsDraw(chart, args, options) {
                const { ctx, chartArea, scales } = chart;
                const hoveredPoint = chart.canvas.id === 'compassChart1' ? hoveredCategoryPoint1 : hoveredCategoryPoint2;

                if (!hoveredPoint || !hoveredPoint.matches || hoveredPoint.matches.length === 0) {
                    return;
                }

                const individualDataset = chart.data.datasets[0];  // Individual respondents dataset

                ctx.save();
                ctx.strokeStyle = 'rgba(100, 100, 255, 0.2)';
                ctx.lineWidth = 1;

                // Draw lines from category point to each matching individual
                hoveredPoint.matches.forEach(index => {
                    const individual = individualDataset.data[index];
                    if (!individual) return;

                    const categoryX = scales.x.getPixelForValue(hoveredPoint.x);
                    const categoryY = scales.y.getPixelForValue(hoveredPoint.y);
                    const indX = scales.x.getPixelForValue(individual.x);
                    const indY = scales.y.getPixelForValue(individual.y);

                    ctx.beginPath();
                    ctx.moveTo(categoryX, categoryY);
                    ctx.lineTo(indX, indY);
                    ctx.stroke();
                });

                ctx.restore();
            }
        };

        function addJitter(value, amount = 0.08) {
            return value + (Math.random() - 0.5) * amount;
        }

        function processIndividualRespondents(xCol, yCol, categories) {
            const individuals = [];

            surveyData.forEach((row, idx) => {
                const x = parseFloat(row[xCol]);
                const y = parseFloat(row[yCol]);

                if (!isNaN(x) && !isNaN(y)) {
                    const categoryValues = {};
                    categories.forEach(cat => {
                        categoryValues[cat.col] = row[cat.col];
                    });

                    individuals.push({
                        x: addJitter(x),
                        y: addJitter(y),
                        originalX: x,
                        originalY: y,
                        categories: categoryValues,
                        respondentId: idx
                    });
                }
            });

            return individuals;
        }

        function processCategory(categoryCol, xCol, yCol, minCount) {
            const groups = {};

            surveyData.forEach(row => {
                const value = row[categoryCol];
                if (!value || value.trim() === '') return;

                if (!groups[value]) {
                    groups[value] = {
                        xScores: [],
                        yScores: []
                    };
                }

                const x = parseFloat(row[xCol]);
                const y = parseFloat(row[yCol]);

                if (!isNaN(x)) groups[value].xScores.push(x);
                if (!isNaN(y)) groups[value].yScores.push(y);
            });

            const result = [];
            for (const [label, data] of Object.entries(groups)) {
                if (data.xScores.length >= minCount && data.yScores.length >= minCount) {
                    const avgX = data.xScores.reduce((a, b) => a + b, 0) / data.xScores.length;
                    const avgY = data.yScores.reduce((a, b) => a + b, 0) / data.yScores.length;

                    result.push({
                        label: label,
                        x: avgX,
                        y: avgY,
                        invertedY: 6 - avgY,
                        count: data.xScores.length
                    });
                }
            }

            return result;
        }

        function getColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            const xNorm = (x - 1) / 4;
            const alphaNorm = Math.pow(xNorm, 2);
            const alpha = 0.25 + (alphaNorm * 0.75);

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getBorderColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getHoverColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgba(${r}, ${g}, ${b}, 1.0)`;
        }

        function calculateVisibleLabels(allData, visibleSet) {
            visibleSet.clear();

            if (!allData || allData.length === 0) return;

            const centerX = 3;
            const centerY = 3;

            const quadrants = {
                topLeft: [],
                topRight: [],
                bottomLeft: [],
                bottomRight: []
            };

            allData.forEach((d, i) => {
                const point = {
                    index: i,
                    x: d.x,
                    y: d.y,
                    count: d.count,
                    label: d.label
                };

                if (d.x < centerX && d.y < centerY) {
                    quadrants.topLeft.push(point);
                } else if (d.x >= centerX && d.y < centerY) {
                    quadrants.topRight.push(point);
                } else if (d.x < centerX && d.y >= centerY) {
                    quadrants.bottomLeft.push(point);
                } else {
                    quadrants.bottomRight.push(point);
                }
            });

            Object.keys(quadrants).forEach(key => {
                quadrants[key].sort((a, b) => b.count - a.count);
            });

            const threshold = collisionThreshold;
            const shownLabels = [];

            const addFromQuadrant = (points, maxFromQuadrant) => {
                let added = 0;
                for (let candidate of points) {
                    if (added >= maxFromQuadrant) break;

                    let hasCollision = false;
                    for (let shown of shownLabels) {
                        const distance = Math.sqrt(
                            Math.pow(candidate.x - shown.x, 2) +
                            Math.pow(candidate.y - shown.y, 2)
                        );
                        if (distance < threshold) {
                            hasCollision = true;
                            break;
                        }
                    }

                    if (!hasCollision) {
                        shownLabels.push(candidate);
                        visibleSet.add(candidate.index);
                        added++;
                    }
                }
            };

            addFromQuadrant(quadrants.topLeft, 2);
            addFromQuadrant(quadrants.topRight, 2);
            addFromQuadrant(quadrants.bottomLeft, 2);
            addFromQuadrant(quadrants.bottomRight, 2);

            const allRemaining = [
                ...quadrants.topLeft,
                ...quadrants.topRight,
                ...quadrants.bottomLeft,
                ...quadrants.bottomRight
            ].filter(p => !visibleSet.has(p.index))
             .sort((a, b) => b.count - a.count);

            for (let candidate of allRemaining) {
                if (shownLabels.length >= 25) break;

                let hasCollision = false;
                for (let shown of shownLabels) {
                    const distance = Math.sqrt(
                        Math.pow(candidate.x - shown.x, 2) +
                        Math.pow(candidate.y - shown.y, 2)
                    );
                    if (distance < threshold) {
                        hasCollision = true;
                        break;
                    }
                }

                if (!hasCollision) {
                    shownLabels.push(candidate);
                    visibleSet.add(candidate.index);
                }
            }
        }

        function createCompassChart1() {
            const canvas = document.getElementById('compassChart1');
            const ctx = canvas.getContext('2d');

            let rawData = [
                ...processedData.dinner,
                ...processedData.workplace,
                ...processedData.podcast
            ];

            // Create allData with y set to invertedY for collision detection
            let allData = rawData.map(d => ({
                ...d,
                displayY: d.invertedY,
                y: d.invertedY  // For collision detection
            }));

            const minVal = 1;
            const maxVal = 5;

            calculateVisibleLabels(allData, visibleLabelIndices1);

            // Process individual respondents
            const individuals = processIndividualRespondents(
                'I believe AGI is likely within the next 10 years.',
                'We should slow down AI progress until safety is better understood.',
                [
                    {col: 'Who would you most want to have dinner with?'},
                    {col: 'I would most want to work at:'},
                    {col: 'What is your favorite ML related podcast?'}
                ]
            );

            // Create individual points dataset (rendered first, so behind category points)
            const individualDataset = {
                label: 'Individual Respondents',
                data: individuals.map(ind => ({
                    x: ind.x,
                    y: 6 - ind.y,  // Invert Y for display
                    categories: ind.categories,
                    respondentId: ind.respondentId,
                    originalX: ind.originalX,
                    originalY: ind.originalY
                })),
                backgroundColor: individuals.map(ind => {
                    // Color based on coordinates with reduced opacity
                    const color = getColorForPoint(ind.originalX, ind.originalY);
                    return color.replace(/[\d.]+\)$/, '0.2)');  // Set opacity to 0.2
                }),
                borderColor: individuals.map(ind => {
                    const color = getBorderColorForPoint(ind.originalX, ind.originalY);
                    return color.replace('rgb', 'rgba').replace(')', ', 0.4)');
                }),
                borderWidth: 0.5,
                pointRadius: 2,
                pointHoverRadius: 3,
                pointHoverBackgroundColor: individuals.map(ind => getColorForPoint(ind.originalX, ind.originalY)),
                pointHoverBorderColor: individuals.map(ind => getBorderColorForPoint(ind.originalX, ind.originalY)),
                pointHoverBorderWidth: 1.5,
                datalabels: {
                    display: false  // No labels for individual points
                }
            };

            // Create category averages dataset
            const categoryDataset = {
                label: 'Category Averages',
                data: allData.map(d => ({
                    x: d.x,
                    y: d.displayY,
                    label: d.label,
                    count: d.count,
                    xVal: d.x,
                    yVal: 6 - d.displayY,  // Convert back to original safety value
                    categoryLabel: d.label
                })),
                backgroundColor: rawData.map(d => getColorForPoint(d.x, d.y)),
                borderColor: rawData.map(d => getBorderColorForPoint(d.x, d.y)),
                borderWidth: 1.5,
                pointRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverBackgroundColor: rawData.map(d => getHoverColorForPoint(d.x, d.y)),
                pointHoverBorderColor: rawData.map(d => getBorderColorForPoint(d.x, d.y)),
                pointHoverBorderWidth: 2.5,
            };

            chart1Instance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [individualDataset, categoryDataset] },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `${point.label}`,
                                        `AGI Timeline: ${point.xVal.toFixed(2)}/5`,
                                        `Safety Priority: ${point.yVal.toFixed(2)}/5`,
                                        `Responses: ${point.count}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                return context.hovered || visibleLabelIndices1.has(context.dataIndex);
                            },
                            align: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                const mid = (minVal + maxVal) / 2;
                                if (point.x > mid && point.y < mid) return 'right';
                                if (point.x < mid && point.y < mid) return 'left';
                                if (point.x > mid && point.y > mid) return 'right';
                                return 'left';
                            },
                            offset: 6,
                            color: '#000',
                            font: { size: 9, weight: '600', family: 'Arial, sans-serif' },
                            formatter: function(value) {
                                const label = value.label;
                                return label.length > 18 ? label.substring(0, 16) + '...' : label;
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: function(context) {
                                return context.hovered ? '#000' : '#999';
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 4
                        }
                    },
                    onHover: function(event, activeElements) {
                        if (activeElements.length > 0) {
                            const element = activeElements[0];
                            const datasetIndex = element.datasetIndex;
                            const dataIndex = element.index;

                            // Only trigger on category dataset (index 1)
                            if (datasetIndex === 1) {
                                const categoryLabel = categoryDataset.data[dataIndex].categoryLabel;
                                const categoryPoint = categoryDataset.data[dataIndex];

                                // Find matching individuals and their indices
                                const matchingIndices = [];
                                const colors = individuals.map((ind, idx) => {
                                    const matches = Object.values(ind.categories).includes(categoryLabel);
                                    if (matches) matchingIndices.push(idx);
                                    // Keep original color but adjust opacity
                                    const baseColor = getColorForPoint(ind.originalX, ind.originalY);
                                    return matches ? baseColor : baseColor.replace(/[\d.]+\)$/, '0.05)');
                                });
                                const borderColors = individuals.map(ind => {
                                    const matches = Object.values(ind.categories).includes(categoryLabel);
                                    const baseBorder = getBorderColorForPoint(ind.originalX, ind.originalY);
                                    return matches ? baseBorder : baseBorder.replace('rgb', 'rgba').replace(')', ', 0.1)');
                                });

                                // Store hovered category point for line drawing
                                hoveredCategoryPoint1 = {
                                    x: categoryPoint.x,
                                    y: categoryPoint.y,
                                    matches: matchingIndices
                                };

                                chart1Instance.data.datasets[0].backgroundColor = colors;
                                chart1Instance.data.datasets[0].borderColor = borderColors;
                                chart1Instance.update('none');
                            }
                        } else {
                            // Reset to default when not hovering
                            hoveredCategoryPoint1 = null;
                            chart1Instance.data.datasets[0].backgroundColor = individuals.map(ind => {
                                const color = getColorForPoint(ind.originalX, ind.originalY);
                                return color.replace(/[\d.]+\)$/, '0.2)');
                            });
                            chart1Instance.data.datasets[0].borderColor = individuals.map(ind => {
                                const color = getBorderColorForPoint(ind.originalX, ind.originalY);
                                return color.replace('rgb', 'rgba').replace(')', ', 0.4)');
                            });
                            chart1Instance.update('none');
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'AGI Likely Within 10 Years →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: { stepSize: 1 },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '← Prioritize AI Safety (Inverted)',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return 6 - value;
                                }
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels, connectionLinesPlugin]
            });
        }

        function createCompassChart2() {
            const canvas = document.getElementById('compassChart2');
            const ctx = canvas.getContext('2d');

            let allData = [
                ...processedData2.dinner,
                ...processedData2.workplace,
                ...processedData2.podcast
            ];

            const minVal = 1;
            const maxVal = 5;

            calculateVisibleLabels(allData, visibleLabelIndices2);

            // Process individual respondents for second compass
            const individuals = processIndividualRespondents(
                'I’d rather build a working prototype than write a perfect paper.',
                'I believe creativity is more important than rigor in research.',
                [
                    {col: 'Who would you most want to have dinner with?'},
                    {col: 'I would most want to work at:'},
                    {col: 'What is your favorite ML related podcast?'}
                ]
            );

            // Create individual points dataset
            const individualDataset = {
                label: 'Individual Respondents',
                data: individuals.map(ind => ({
                    x: ind.x,
                    y: ind.y,  // No inversion for second chart
                    categories: ind.categories,
                    respondentId: ind.respondentId,
                    originalX: ind.originalX,
                    originalY: ind.originalY
                })),
                backgroundColor: individuals.map(ind => {
                    // Color based on coordinates with reduced opacity
                    const color = getColorForPoint(ind.originalX, ind.originalY);
                    return color.replace(/[\d.]+\)$/, '0.2)');  // Set opacity to 0.2
                }),
                borderColor: individuals.map(ind => {
                    const color = getBorderColorForPoint(ind.originalX, ind.originalY);
                    return color.replace('rgb', 'rgba').replace(')', ', 0.4)');
                }),
                borderWidth: 0.5,
                pointRadius: 2,
                pointHoverRadius: 3,
                pointHoverBackgroundColor: individuals.map(ind => getColorForPoint(ind.originalX, ind.originalY)),
                pointHoverBorderColor: individuals.map(ind => getBorderColorForPoint(ind.originalX, ind.originalY)),
                pointHoverBorderWidth: 1.5,
                datalabels: {
                    display: false
                }
            };

            // Create category averages dataset
            const categoryDataset = {
                label: 'Category Averages',
                data: allData.map(d => ({
                    x: d.x,
                    y: d.y,  // Use regular Y, not inverted
                    label: d.label,
                    count: d.count,
                    xVal: d.x,
                    yVal: d.y,
                    categoryLabel: d.label
                })),
                backgroundColor: allData.map(d => getColorForPoint(d.x, d.y)),
                borderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                borderWidth: 1.5,
                pointRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverBackgroundColor: allData.map(d => getHoverColorForPoint(d.x, d.y)),
                pointHoverBorderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                pointHoverBorderWidth: 2.5,
            };

            chart2Instance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [individualDataset, categoryDataset] },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `${point.label}`,
                                        `Prototype vs Paper: ${point.xVal.toFixed(2)}/5`,
                                        `Creativity vs Rigor: ${point.yVal.toFixed(2)}/5`,
                                        `Responses: ${point.count}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                return context.hovered || visibleLabelIndices2.has(context.dataIndex);
                            },
                            align: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                const mid = (minVal + maxVal) / 2;
                                if (point.x > mid && point.y < mid) return 'right';
                                if (point.x < mid && point.y < mid) return 'left';
                                if (point.x > mid && point.y > mid) return 'right';
                                return 'left';
                            },
                            offset: 6,
                            color: '#000',
                            font: { size: 9, weight: '600', family: 'Arial, sans-serif' },
                            formatter: function(value) {
                                const label = value.label;
                                return label.length > 18 ? label.substring(0, 16) + '...' : label;
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: function(context) {
                                return context.hovered ? '#000' : '#999';
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 4
                        }
                    },
                    onHover: function(event, activeElements) {
                        if (activeElements.length > 0) {
                            const element = activeElements[0];
                            const datasetIndex = element.datasetIndex;
                            const dataIndex = element.index;

                            // Only trigger on category dataset (index 1)
                            if (datasetIndex === 1) {
                                const categoryLabel = categoryDataset.data[dataIndex].categoryLabel;
                                const categoryPoint = categoryDataset.data[dataIndex];

                                // Find matching individuals and their indices
                                const matchingIndices = [];
                                const colors = individuals.map((ind, idx) => {
                                    const matches = Object.values(ind.categories).includes(categoryLabel);
                                    if (matches) matchingIndices.push(idx);
                                    // Keep original color but adjust opacity
                                    const baseColor = getColorForPoint(ind.originalX, ind.originalY);
                                    return matches ? baseColor : baseColor.replace(/[\d.]+\)$/, '0.05)');
                                });
                                const borderColors = individuals.map(ind => {
                                    const matches = Object.values(ind.categories).includes(categoryLabel);
                                    const baseBorder = getBorderColorForPoint(ind.originalX, ind.originalY);
                                    return matches ? baseBorder : baseBorder.replace('rgb', 'rgba').replace(')', ', 0.1)');
                                });

                                // Store hovered category point for line drawing
                                hoveredCategoryPoint2 = {
                                    x: categoryPoint.x,
                                    y: categoryPoint.y,
                                    matches: matchingIndices
                                };

                                chart2Instance.data.datasets[0].backgroundColor = colors;
                                chart2Instance.data.datasets[0].borderColor = borderColors;
                                chart2Instance.update('none');
                            }
                        } else {
                            // Reset to default when not hovering
                            hoveredCategoryPoint2 = null;
                            chart2Instance.data.datasets[0].backgroundColor = individuals.map(ind => {
                                const color = getColorForPoint(ind.originalX, ind.originalY);
                                return color.replace(/[\d.]+\)$/, '0.2)');
                            });
                            chart2Instance.data.datasets[0].borderColor = individuals.map(ind => {
                                const color = getBorderColorForPoint(ind.originalX, ind.originalY);
                                return color.replace('rgb', 'rgba').replace(')', ', 0.4)');
                            });
                            chart2Instance.update('none');
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Prefer Prototypes Over Papers →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: { stepSize: 1 },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Creativity Over Rigor →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: {
                                stepSize: 1
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels, connectionLinesPlugin]
            });
        }

        function createPieCharts() {
            // Dinner pie chart
            const dinnerCounts = {};
            surveyData.forEach(row => {
                const value = row['Who would you most want to have dinner with?'];
                if (value && value.trim() !== '') {
                    dinnerCounts[value] = (dinnerCounts[value] || 0) + 1;
                }
            });
            const dinnerEntries = Object.entries(dinnerCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

            new Chart(document.getElementById('dinnerPieChart'), {
                type: 'pie',
                data: {
                    labels: dinnerEntries.map(d => d[0]),
                    datasets: [{
                        data: dinnerEntries.map(d => d[1]),
                        backgroundColor: generateColors(dinnerEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                if (percentage < 5) return '';  // Hide small slices
                                return label + '\n' + percentage + '%';
                            },
                            align: 'start',
                            anchor: 'end',
                            offset: 4,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 3,
                            clamp: true
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            // Workplace pie chart
            const workplaceCounts = {};
            surveyData.forEach(row => {
                const value = row['I would most want to work at:'];
                if (value && value.trim() !== '') {
                    workplaceCounts[value] = (workplaceCounts[value] || 0) + 1;
                }
            });
            const workplaceEntries = Object.entries(workplaceCounts).sort((a, b) => b[1] - a[1]);

            new Chart(document.getElementById('workplacePieChart'), {
                type: 'pie',
                data: {
                    labels: workplaceEntries.map(d => d[0]),
                    datasets: [{
                        data: workplaceEntries.map(d => d[1]),
                        backgroundColor: generateColors(workplaceEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                if (percentage < 5) return '';  // Hide small slices
                                return label + '\n' + percentage + '%';
                            },
                            align: 'start',
                            anchor: 'end',
                            offset: 4,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 3,
                            clamp: true
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            // Podcast pie chart
            const podcastCounts = {};
            surveyData.forEach(row => {
                const value = row['What is your favorite ML related podcast?'];
                if (value && value.trim() !== '') {
                    podcastCounts[value] = (podcastCounts[value] || 0) + 1;
                }
            });
            const podcastEntries = Object.entries(podcastCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

            new Chart(document.getElementById('podcastPieChart'), {
                type: 'pie',
                data: {
                    labels: podcastEntries.map(d => d[0]),
                    datasets: [{
                        data: podcastEntries.map(d => d[1]),
                        backgroundColor: generateColors(podcastEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                if (percentage < 5) return '';  // Hide small slices
                                return label + '\n' + percentage + '%';
                            },
                            align: 'start',
                            anchor: 'end',
                            offset: 4,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 3,
                            clamp: true
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                colors.push(`hsl(${hue}, 60%, 60%)`);
            }
            return colors;
        }
    </script>
</body>
</html>
