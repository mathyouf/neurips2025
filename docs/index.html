<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeurIPS Twin Survey 2025 - Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            background: #ffffff;
            color: #000;
            line-height: 1.6;
            padding: 40px 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #000;
        }

        .authors {
            font-size: 1.1em;
            margin-bottom: 10px;
            font-style: italic;
        }

        .affiliation {
            font-size: 0.95em;
            color: #333;
            margin-bottom: 20px;
        }

        .abstract {
            max-width: 900px;
            margin: 20px auto;
            text-align: justify;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .abstract strong {
            font-weight: bold;
        }

        h2 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 40px 0 20px 0;
            color: #000;
        }

        .section {
            margin: 40px 0;
        }

        .compass-section {
            margin: 40px 0;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 30px auto;
            aspect-ratio: 1 / 1;
        }

        .pie-charts-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin: 40px 0;
        }

        .pie-chart-wrapper {
            background: #f9f9f9;
            padding: 20px;
            border: 1px solid #ddd;
        }

        .pie-chart-wrapper h3 {
            font-size: 1em;
            margin-bottom: 15px;
            text-align: center;
            color: #000;
        }

        .pie-chart-container {
            position: relative;
            width: 100%;
            max-width: 350px;
            margin: 0 auto;
        }

        .figure-caption {
            text-align: center;
            font-size: 0.9em;
            margin: 15px auto 0;
            max-width: 800px;
            color: #333;
        }

        .figure-caption strong {
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: #666;
        }

        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            text-align: center;
            font-size: 0.85em;
            color: #666;
        }

        footer a {
            color: #000;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NeurIPS Twin Survey 2025: Understanding AI Researcher Perspectives</h1>
            <div class="authors">Anonymous Authors</div>
            <div class="affiliation">NeurIPS 2025</div>
            <div class="abstract">
                <strong>Abstract.</strong> We present an analysis of survey data (N=335) collected from AI researchers
                attending NeurIPS 2025. The survey captures perspectives on AGI timelines, AI safety concerns,
                workplace preferences, and research methodologies. We visualize the relationship between beliefs
                using two-dimensional political compasses, revealing distinct clusters of researcher perspectives.
            </div>
        </header>

        <div id="loading" class="loading">Loading survey data...</div>

        <div id="content" style="display: none;">
            <section class="section compass-section">
                <h2>1. Political Compass: AGI Beliefs vs. Safety Priorities</h2>
                <div class="chart-container">
                    <canvas id="compassChart1"></canvas>
                </div>
                <div class="figure-caption">
                    <strong>Figure 1:</strong> Political compass mapping AI researcher positions based on AGI timeline
                    beliefs (X-axis, 1-5 Likert scale) and AI safety priorities (Y-axis, inverted 1-5 scale). Each point
                    represents the average position of researchers sharing a categorical preference. Color indicates
                    safety priority through a blue-white-red gradient (blue = move fast, red = prioritize safety).
                    Opacity encodes AGI timeline belief strength (faint = skeptical, solid = believer).
                </div>
            </section>

            <section class="section">
                <h2>2. Categorical Response Distributions</h2>
                <div class="pie-charts-container">
                    <div class="pie-chart-wrapper">
                        <h3>Dream Dinner Companion</h3>
                        <div class="pie-chart-container">
                            <canvas id="dinnerPieChart"></canvas>
                        </div>
                    </div>
                    <div class="pie-chart-wrapper">
                        <h3>Preferred Workplace</h3>
                        <div class="pie-chart-container">
                            <canvas id="workplacePieChart"></canvas>
                        </div>
                    </div>
                    <div class="pie-chart-wrapper">
                        <h3>Favorite ML Podcast</h3>
                        <div class="pie-chart-container">
                            <canvas id="podcastPieChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <section class="section compass-section">
                <h2>3. Political Compass: Prototype vs. Paper & Creativity vs. Rigor</h2>
                <div class="chart-container">
                    <canvas id="compassChart2"></canvas>
                </div>
                <div class="figure-caption">
                    <strong>Figure 2:</strong> Second political compass showing the relationship between preference for
                    prototypes vs. papers (X-axis) and belief in creativity vs. rigor (Y-axis). Color encodes Y-axis
                    position (blue = rigor-focused, red = creativity-focused). Opacity encodes X-axis belief strength
                    (faint = prefer papers, solid = prefer prototypes).
                </div>
            </section>
        </div>

        <footer>
            <p>NeurIPS Twin Survey 2025 | <a href="https://github.com/mathyouf/neurips2025">View on GitHub</a></p>
        </footer>
    </div>

    <script>
        let surveyData = null;
        let processedData = {
            dinner: [],
            workplace: [],
            podcast: []
        };
        let processedData2 = {
            dinner: [],
            workplace: [],
            podcast: []
        };
        const collisionThreshold = 0.2;
        let visibleLabelIndices1 = new Set();
        let visibleLabelIndices2 = new Set();

        Papa.parse('neuripstwin7.csv', {
            download: true,
            header: true,
            complete: function(results) {
                surveyData = results.data.filter(row => row.Timestamp && row.Timestamp.trim() !== '');
                console.log('Loaded', surveyData.length, 'responses');

                // Process data for first compass (AGI vs Safety)
                processedData.dinner = processCategory(
                    'Who would you most want to have dinner with?',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    3
                );
                processedData.workplace = processCategory(
                    'I would most want to work at:',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    3
                );
                processedData.podcast = processCategory(
                    'What is your favorite ML related podcast?',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    5
                );

                // Process data for second compass (Prototype vs Creativity)
                processedData2.dinner = processCategory(
                    'Who would you most want to have dinner with?',
                    "I'd rather build a working prototype than write a perfect paper.",
                    'I believe creativity is more important than rigor in research.',
                    3
                );
                processedData2.workplace = processCategory(
                    'I would most want to work at:',
                    "I'd rather build a working prototype than write a perfect paper.",
                    'I believe creativity is more important than rigor in research.',
                    3
                );
                processedData2.podcast = processCategory(
                    'What is your favorite ML related podcast?',
                    "I'd rather build a working prototype than write a perfect paper.",
                    'I believe creativity is more important than rigor in research.',
                    5
                );

                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                console.log('First compass data points:',
                    processedData.dinner.length + processedData.workplace.length + processedData.podcast.length);
                console.log('Second compass data points:',
                    processedData2.dinner.length + processedData2.workplace.length + processedData2.podcast.length);
                console.log('Sample from second compass:', processedData2.dinner.slice(0, 3));

                createCompassChart1();
                createCompassChart2();
                createPieCharts();
            },
            error: function(error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 'Error loading data. Please check the console.';
            }
        });

        function processCategory(categoryCol, xCol, yCol, minCount) {
            const groups = {};

            surveyData.forEach(row => {
                const value = row[categoryCol];
                if (!value || value.trim() === '') return;

                if (!groups[value]) {
                    groups[value] = {
                        xScores: [],
                        yScores: []
                    };
                }

                const x = parseFloat(row[xCol]);
                const y = parseFloat(row[yCol]);

                if (!isNaN(x)) groups[value].xScores.push(x);
                if (!isNaN(y)) groups[value].yScores.push(y);
            });

            const result = [];
            for (const [label, data] of Object.entries(groups)) {
                if (data.xScores.length >= minCount && data.yScores.length >= minCount) {
                    const avgX = data.xScores.reduce((a, b) => a + b, 0) / data.xScores.length;
                    const avgY = data.yScores.reduce((a, b) => a + b, 0) / data.yScores.length;

                    result.push({
                        label: label,
                        x: avgX,
                        y: avgY,
                        invertedY: 6 - avgY,
                        count: data.xScores.length
                    });
                }
            }

            return result;
        }

        function getColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            const xNorm = (x - 1) / 4;
            const alphaNorm = Math.pow(xNorm, 2);
            const alpha = 0.25 + (alphaNorm * 0.75);

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getBorderColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getHoverColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgba(${r}, ${g}, ${b}, 1.0)`;
        }

        function calculateVisibleLabels(allData, visibleSet) {
            visibleSet.clear();

            if (!allData || allData.length === 0) return;

            const centerX = 3;
            const centerY = 3;

            const quadrants = {
                topLeft: [],
                topRight: [],
                bottomLeft: [],
                bottomRight: []
            };

            allData.forEach((d, i) => {
                const point = {
                    index: i,
                    x: d.x,
                    y: d.invertedY,
                    count: d.count,
                    label: d.label
                };

                if (d.x < centerX && d.invertedY < centerY) {
                    quadrants.topLeft.push(point);
                } else if (d.x >= centerX && d.invertedY < centerY) {
                    quadrants.topRight.push(point);
                } else if (d.x < centerX && d.invertedY >= centerY) {
                    quadrants.bottomLeft.push(point);
                } else {
                    quadrants.bottomRight.push(point);
                }
            });

            Object.keys(quadrants).forEach(key => {
                quadrants[key].sort((a, b) => b.count - a.count);
            });

            const threshold = collisionThreshold;
            const shownLabels = [];

            const addFromQuadrant = (points, maxFromQuadrant) => {
                let added = 0;
                for (let candidate of points) {
                    if (added >= maxFromQuadrant) break;

                    let hasCollision = false;
                    for (let shown of shownLabels) {
                        const distance = Math.sqrt(
                            Math.pow(candidate.x - shown.x, 2) +
                            Math.pow(candidate.y - shown.y, 2)
                        );
                        if (distance < threshold) {
                            hasCollision = true;
                            break;
                        }
                    }

                    if (!hasCollision) {
                        shownLabels.push(candidate);
                        visibleSet.add(candidate.index);
                        added++;
                    }
                }
            };

            addFromQuadrant(quadrants.topLeft, 2);
            addFromQuadrant(quadrants.topRight, 2);
            addFromQuadrant(quadrants.bottomLeft, 2);
            addFromQuadrant(quadrants.bottomRight, 2);

            const allRemaining = [
                ...quadrants.topLeft,
                ...quadrants.topRight,
                ...quadrants.bottomLeft,
                ...quadrants.bottomRight
            ].filter(p => !visibleSet.has(p.index))
             .sort((a, b) => b.count - a.count);

            for (let candidate of allRemaining) {
                if (shownLabels.length >= 25) break;

                let hasCollision = false;
                for (let shown of shownLabels) {
                    const distance = Math.sqrt(
                        Math.pow(candidate.x - shown.x, 2) +
                        Math.pow(candidate.y - shown.y, 2)
                    );
                    if (distance < threshold) {
                        hasCollision = true;
                        break;
                    }
                }

                if (!hasCollision) {
                    shownLabels.push(candidate);
                    visibleSet.add(candidate.index);
                }
            }
        }

        function createCompassChart1() {
            const canvas = document.getElementById('compassChart1');
            const ctx = canvas.getContext('2d');

            let allData = [
                ...processedData.dinner,
                ...processedData.workplace,
                ...processedData.podcast
            ];

            const minVal = 1;
            const maxVal = 5;

            calculateVisibleLabels(allData, visibleLabelIndices1);

            const dataset = {
                label: 'Researchers',
                data: allData.map(d => ({
                    x: d.x,
                    y: d.invertedY,
                    label: d.label,
                    count: d.count,
                    xVal: d.x,
                    yVal: d.y
                })),
                backgroundColor: allData.map(d => getColorForPoint(d.x, d.y)),
                borderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                borderWidth: 1.5,
                pointRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverBackgroundColor: allData.map(d => getHoverColorForPoint(d.x, d.y)),
                pointHoverBorderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                pointHoverBorderWidth: 2.5,
            };

            new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [dataset] },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `${point.label}`,
                                        `AGI Timeline: ${point.xVal.toFixed(2)}/5`,
                                        `Safety Priority: ${point.yVal.toFixed(2)}/5`,
                                        `Responses: ${point.count}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                return context.hovered || visibleLabelIndices1.has(context.dataIndex);
                            },
                            align: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                const mid = (minVal + maxVal) / 2;
                                if (point.x > mid && point.y < mid) return 'right';
                                if (point.x < mid && point.y < mid) return 'left';
                                if (point.x > mid && point.y > mid) return 'right';
                                return 'left';
                            },
                            offset: 6,
                            color: '#000',
                            font: { size: 9, weight: '600', family: 'Arial, sans-serif' },
                            formatter: function(value) {
                                const label = value.label;
                                return label.length > 18 ? label.substring(0, 16) + '...' : label;
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: function(context) {
                                return context.hovered ? '#000' : '#999';
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 4
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'AGI Likely Within 10 Years →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: { stepSize: 1 },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '← Prioritize AI Safety (Inverted)',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return 6 - value;
                                }
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function createCompassChart2() {
            const canvas = document.getElementById('compassChart2');
            const ctx = canvas.getContext('2d');

            let allData = [
                ...processedData2.dinner,
                ...processedData2.workplace,
                ...processedData2.podcast
            ];

            const minVal = 1;
            const maxVal = 5;

            calculateVisibleLabels(allData, visibleLabelIndices2);

            const dataset = {
                label: 'Researchers',
                data: allData.map(d => ({
                    x: d.x,
                    y: d.invertedY,
                    label: d.label,
                    count: d.count,
                    xVal: d.x,
                    yVal: d.y
                })),
                backgroundColor: allData.map(d => getColorForPoint(d.x, d.y)),
                borderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                borderWidth: 1.5,
                pointRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverBackgroundColor: allData.map(d => getHoverColorForPoint(d.x, d.y)),
                pointHoverBorderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                pointHoverBorderWidth: 2.5,
            };

            new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [dataset] },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `${point.label}`,
                                        `Prototype vs Paper: ${point.xVal.toFixed(2)}/5`,
                                        `Creativity vs Rigor: ${point.yVal.toFixed(2)}/5`,
                                        `Responses: ${point.count}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                return context.hovered || visibleLabelIndices2.has(context.dataIndex);
                            },
                            align: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                const mid = (minVal + maxVal) / 2;
                                if (point.x > mid && point.y < mid) return 'right';
                                if (point.x < mid && point.y < mid) return 'left';
                                if (point.x > mid && point.y > mid) return 'right';
                                return 'left';
                            },
                            offset: 6,
                            color: '#000',
                            font: { size: 9, weight: '600', family: 'Arial, sans-serif' },
                            formatter: function(value) {
                                const label = value.label;
                                return label.length > 18 ? label.substring(0, 16) + '...' : label;
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: function(context) {
                                return context.hovered ? '#000' : '#999';
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 4
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Prefer Prototypes Over Papers →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: { stepSize: 1 },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '← Creativity Over Rigor (Inverted)',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minVal,
                            max: maxVal,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return 6 - value;
                                }
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function createPieCharts() {
            // Dinner pie chart
            const dinnerCounts = {};
            surveyData.forEach(row => {
                const value = row['Who would you most want to have dinner with?'];
                if (value && value.trim() !== '') {
                    dinnerCounts[value] = (dinnerCounts[value] || 0) + 1;
                }
            });
            const dinnerEntries = Object.entries(dinnerCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

            new Chart(document.getElementById('dinnerPieChart'), {
                type: 'pie',
                data: {
                    labels: dinnerEntries.map(d => d[0]),
                    datasets: [{
                        data: dinnerEntries.map(d => d[1]),
                        backgroundColor: generateColors(dinnerEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                return label + '\n' + percentage + '%';
                            },
                            align: 'end',
                            anchor: 'end',
                            offset: 10,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 4
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            // Workplace pie chart
            const workplaceCounts = {};
            surveyData.forEach(row => {
                const value = row['I would most want to work at:'];
                if (value && value.trim() !== '') {
                    workplaceCounts[value] = (workplaceCounts[value] || 0) + 1;
                }
            });
            const workplaceEntries = Object.entries(workplaceCounts).sort((a, b) => b[1] - a[1]);

            new Chart(document.getElementById('workplacePieChart'), {
                type: 'pie',
                data: {
                    labels: workplaceEntries.map(d => d[0]),
                    datasets: [{
                        data: workplaceEntries.map(d => d[1]),
                        backgroundColor: generateColors(workplaceEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                return label + '\n' + percentage + '%';
                            },
                            align: 'end',
                            anchor: 'end',
                            offset: 10,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 4
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            // Podcast pie chart
            const podcastCounts = {};
            surveyData.forEach(row => {
                const value = row['What is your favorite ML related podcast?'];
                if (value && value.trim() !== '') {
                    podcastCounts[value] = (podcastCounts[value] || 0) + 1;
                }
            });
            const podcastEntries = Object.entries(podcastCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

            new Chart(document.getElementById('podcastPieChart'), {
                type: 'pie',
                data: {
                    labels: podcastEntries.map(d => d[0]),
                    datasets: [{
                        data: podcastEntries.map(d => d[1]),
                        backgroundColor: generateColors(podcastEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                return label + '\n' + percentage + '%';
                            },
                            align: 'end',
                            anchor: 'end',
                            offset: 10,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 4
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                colors.push(`hsl(${hue}, 60%, 60%)`);
            }
            return colors;
        }
    </script>
</body>
</html>
