<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeurIPS Twin Survey 2025 - Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            background: #ffffff;
            color: #000;
            line-height: 1.6;
            padding: 40px 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #000;
        }

        .authors {
            font-size: 1.1em;
            margin-bottom: 10px;
            font-style: italic;
        }

        .affiliation {
            font-size: 0.95em;
            color: #333;
            margin-bottom: 20px;
        }

        .abstract {
            max-width: 900px;
            margin: 20px auto;
            text-align: justify;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .abstract strong {
            font-weight: bold;
        }

        h2 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 40px 0 20px 0;
            color: #000;
        }

        .section {
            margin: 40px 0;
        }

        .compass-section {
            margin: 40px 0;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 30px auto;
            aspect-ratio: 1 / 1;
        }

        .pie-charts-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin: 40px 0;
        }

        .pie-chart-wrapper {
            background: #f9f9f9;
            padding: 40px;
            border: 1px solid #ddd;
        }

        .pie-chart-wrapper h3 {
            font-size: 1em;
            margin-bottom: 15px;
            text-align: center;
            color: #000;
        }

        .pie-chart-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
        }

        .figure-caption {
            text-align: center;
            font-size: 0.9em;
            margin: 15px auto 0;
            max-width: 800px;
            color: #333;
        }

        .figure-caption strong {
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: #666;
        }

        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            text-align: center;
            font-size: 0.85em;
            color: #666;
        }

        footer a {
            color: #000;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NeurIPS Twin Survey 2025: Understanding AI Researcher Perspectives</h1>
            <div class="authors">Anonymous Authors</div>
            <div class="affiliation">NeurIPS 2025</div>
            <div class="abstract">
                <strong>Abstract.</strong> We present an analysis of survey data (N=335) collected from AI researchers
                attending NeurIPS 2025. The survey captures perspectives on AGI timelines, AI safety concerns,
                workplace preferences, and research methodologies. We visualize the relationship between beliefs
                using two-dimensional political compasses, revealing distinct clusters of researcher perspectives.
            </div>
        </header>

        <div id="loading" class="loading">Loading survey data...</div>

        <div id="content" style="display: none;">
            <section class="section" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 30px;">
                <h2 style="margin-top: 0;">Find Yourself</h2>
                <div style="display: flex; flex-direction: column; gap: 15px; max-width: 600px;">
                    <div>
                        <label for="uuidInput" style="display: block; margin-bottom: 5px; font-weight: 600;">Enter your UUID:</label>
                        <input type="text" id="uuidInput" placeholder="Enter your UUID to highlight yourself"
                               style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;">
                    </div>
                    <div>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="showKnnToggle" style="cursor: pointer;">
                            <span style="font-weight: 600;">Show my matches on charts (KNN or Group)</span>
                        </label>
                    </div>
                    <div id="matchModeContainer" style="display: none;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Match by:</label>
                        <div style="display: flex; gap: 20px;">
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                <input type="radio" name="matchMode" value="knn" checked style="cursor: pointer;">
                                <span>Distance (KNN)</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                <input type="radio" name="matchMode" value="group" style="cursor: pointer;">
                                <span>Assigned Group</span>
                            </label>
                        </div>
                    </div>
                    <div id="knnSliderContainer" style="display: none;">
                        <label for="knnSlider" style="display: block; margin-bottom: 5px; font-weight: 600;">
                            Number of nearest neighbors: <span id="knnValue">5</span>
                        </label>
                        <input type="range" id="knnSlider" min="0" max="20" value="5"
                               style="width: 100%;">
                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: #666;">
                            <span>0</span>
                            <span>20</span>
                        </div>
                    </div>
                    <div id="userInfo" style="display: none; background: white; padding: 10px; border-radius: 4px; border: 1px solid #ddd;">
                        <strong>Your position:</strong>
                        <div id="userDetails"></div>
                    </div>
                </div>
            </section>

            <section class="section compass-section">
                <h2>1. Political Compass: AGI Beliefs vs. Safety Priorities</h2>
                <div class="chart-container">
                    <canvas id="compassChart1"></canvas>
                </div>
                <div class="figure-caption">
                    <strong>Figure 1:</strong> Political compass mapping AI researcher positions based on AGI timeline
                    beliefs (X-axis: "I believe AGI is likely within the next 10 years", 1-5 Likert scale) and AI safety
                    priorities (Y-axis: "We should slow down AI progress until safety is better understood", inverted 1-5 scale).
                    Each large point represents the average position of researchers sharing a categorical preference.
                    Small colored dots represent individual respondents (with jitter to prevent overlap), colored based on
                    their position. Color indicates safety priority through a blue-white-red gradient (blue = move fast,
                    red = prioritize safety). Opacity encodes AGI timeline belief strength (faint = skeptical, solid = believer).
                    Hover over a category to highlight its respondents with connecting lines.
                </div>
            </section>

            <section class="section">
                <h2>2. Categorical Response Distributions</h2>
                <div class="pie-charts-container">
                    <div class="pie-chart-wrapper">
                        <h3>Dream Dinner Companion</h3>
                        <div class="pie-chart-container">
                            <canvas id="dinnerPieChart"></canvas>
                        </div>
                        <p style="font-size: 0.8em; text-align: center; margin-top: 15px; color: #333; line-height: 1.5;">
                            <strong>Figure 2a:</strong> Distribution of respondents' preferred dinner companions.
                            Survey item: "Who would you most want to have dinner with?" Shows categorical preferences
                            for intellectual role models among NeurIPS attendees (n=335).
                        </p>
                    </div>
                    <div class="pie-chart-wrapper">
                        <h3>Preferred Workplace</h3>
                        <div class="pie-chart-container">
                            <canvas id="workplacePieChart"></canvas>
                        </div>
                        <p style="font-size: 0.8em; text-align: center; margin-top: 15px; color: #333; line-height: 1.5;">
                            <strong>Figure 2b:</strong> Distribution of respondents' preferred workplace organizations.
                            Survey item: "I would most want to work at:" Reveals institutional preferences and
                            career aspirations within the AI research community (n=335).
                        </p>
                    </div>
                    <div class="pie-chart-wrapper">
                        <h3>Favorite ML Podcast</h3>
                        <div class="pie-chart-container">
                            <canvas id="podcastPieChart"></canvas>
                        </div>
                        <p style="font-size: 0.8em; text-align: center; margin-top: 15px; color: #333; line-height: 1.5;">
                            <strong>Figure 2c:</strong> Distribution of respondents' preferred ML-related podcasts.
                            Survey item: "What is your favorite ML related podcast?" Captures media consumption
                            patterns and information source preferences among researchers (n=335).
                        </p>
                    </div>
                </div>
            </section>

            <section class="section compass-section">
                <h2>3. Political Compass: Prototype vs. Paper & Creativity vs. Rigor</h2>
                <div class="chart-container">
                    <canvas id="compassChart2"></canvas>
                </div>
                <div class="figure-caption">
                    <strong>Figure 2:</strong> Second political compass showing the relationship between preference for
                    prototypes vs. papers (X-axis: "I'd rather build a working prototype than write a perfect paper", 1-5 scale)
                    and belief in creativity vs. rigor (Y-axis: "I believe creativity is more important than rigor in research", 1-5 scale).
                    Each large point represents the average position of researchers sharing a categorical preference.
                    Small colored dots represent individual respondents (with jitter to prevent overlap), colored based on
                    their position. Color encodes Y-axis position (blue = rigor-focused, red = creativity-focused). Opacity
                    encodes X-axis belief strength (faint = prefer papers, solid = prefer prototypes). Hover over a category
                    to highlight its respondents with connecting lines.
                </div>
            </section>

            <section class="section" id="responsesSection" style="display: none;">
                <h2>Your Responses & Nearest Neighbors</h2>
                <div id="responsesContent" style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <!-- Will be populated dynamically -->
                </div>
            </section>
        </div>

        <footer>
            <p>NeurIPS Twin Survey 2025 | <a href="https://github.com/mathyouf/neurips2025">View on GitHub</a></p>
        </footer>
    </div>

    <script>
        let surveyData = null;
        let processedData = {
            dinner: [],
            workplace: [],
            podcast: []
        };
        let processedData2 = {
            dinner: [],
            workplace: [],
            podcast: []
        };
        const collisionThreshold = 0.2;
        let visibleLabelIndices1 = new Set();
        let visibleLabelIndices2 = new Set();
        let hoveredCategory1 = null;
        let hoveredCategory2 = null;
        let chart1Instance = null;
        let chart2Instance = null;
        let hoveredCategoryPoint1 = null;  // Stores {x, y, matches: [indices]}
        let hoveredCategoryPoint2 = null;  // Stores {x, y, matches: [indices]}
        let hoveredIndividual1 = null;  // Stores {x, y, categoryIndices: [indices]}
        let hoveredIndividual2 = null;  // Stores {x, y, categoryIndices: [indices]}
        let hoveredCategoryLabelsToShow1 = new Set();  // Category indices to show labels for
        let hoveredCategoryLabelsToShow2 = new Set();  // Category indices to show labels for
        let groupsData = null;  // Groups data with UUID, email, X, Y
        let highlightedIndices = new Set();  // Indices of user + KNN to highlight
        let currentUserUUID = null;
        let currentK = 5;
        let matchMode = 'knn';  // 'knn' or 'group'
        let showKnnHighlighting = false;  // Toggle for showing KNN/group highlighting

        // Hover state tracking for connection lines
        let hoveredChart1Intersection = null;  // {index, data}
        let hoveredChart2Intersection = null;
        let hoveredChart1Category = null;      // {index, data}
        let hoveredChart2Category = null;

        Papa.parse('neuripstwin7.csv', {
            download: true,
            header: true,
            complete: function(results) {
                surveyData = results.data.filter(row => row.Timestamp && row.Timestamp.trim() !== '');
                console.log('Loaded', surveyData.length, 'responses');

                // Process data for first compass (AGI vs Safety)
                processedData.dinner = processCategory(
                    'Who would you most want to have dinner with?',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    3
                );
                processedData.workplace = processCategory(
                    'I would most want to work at:',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    3
                );
                processedData.podcast = processCategory(
                    'What is your favorite ML related podcast?',
                    'I believe AGI is likely within the next 10 years.',
                    'We should slow down AI progress until safety is better understood.',
                    5
                );

                // Process data for second compass (Prototype vs Creativity)
                processedData2.dinner = processCategory(
                    'Who would you most want to have dinner with?',
                    'I’d rather build a working prototype than write a perfect paper.',
                    'I believe creativity is more important than rigor in research.',
                    3
                );
                processedData2.workplace = processCategory(
                    'I would most want to work at:',
                    'I’d rather build a working prototype than write a perfect paper.',
                    'I believe creativity is more important than rigor in research.',
                    3
                );
                processedData2.podcast = processCategory(
                    'What is your favorite ML related podcast?',
                    'I’d rather build a working prototype than write a perfect paper.',
                    'I believe creativity is more important than rigor in research.',
                    5
                );

                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                console.log('First compass data points:',
                    processedData.dinner.length + processedData.workplace.length + processedData.podcast.length);
                console.log('Second compass data points:',
                    processedData2.dinner.length + processedData2.workplace.length + processedData2.podcast.length);
                console.log('Sample from second compass:', processedData2.dinner.slice(0, 3));

                createCompassChart1();
                createCompassChart2();
                createPieCharts();

                // Load groups data for UUID highlighting
                loadGroupsData();
            },
            error: function(error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 'Error loading data. Please check the console.';
            }
        });

        // Load and process groups data
        function loadGroupsData() {
            Papa.parse('groups_with_uuid.csv', {
                download: true,
                header: true,
                complete: function(results) {
                    groupsData = results.data;
                    console.log('Loaded groups data:', groupsData.length, 'entries');
                    setupUIEventListeners();
                },
                error: function(error) {
                    console.error('Error loading groups data:', error);
                }
            });
        }

        // Set up event listeners for UUID input and k-slider
        function setupUIEventListeners() {
            const uuidInput = document.getElementById('uuidInput');
            const knnSlider = document.getElementById('knnSlider');
            const knnValue = document.getElementById('knnValue');
            const knnSliderContainer = document.getElementById('knnSliderContainer');
            const matchModeContainer = document.getElementById('matchModeContainer');
            const showKnnToggle = document.getElementById('showKnnToggle');
            const matchModeRadios = document.querySelectorAll('input[name="matchMode"]');

            // Check for UUID in URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const uuidFromURL = urlParams.get('uuid');
            if (uuidFromURL) {
                uuidInput.value = uuidFromURL;
                currentUserUUID = uuidFromURL;
            }

            // Handle UUID input
            uuidInput.addEventListener('input', function() {
                const uuid = this.value.trim();
                currentUserUUID = uuid || null;
                if (showKnnHighlighting && uuid) {
                    updateHighlighting();
                } else {
                    clearHighlighting();
                }
            });

            // Handle KNN/group highlighting toggle
            showKnnToggle.addEventListener('change', function() {
                showKnnHighlighting = this.checked;

                // Show/hide match mode options
                if (this.checked) {
                    matchModeContainer.style.display = 'block';
                    // Show KNN slider if in KNN mode
                    if (matchMode === 'knn') {
                        knnSliderContainer.style.display = 'block';
                    }
                } else {
                    matchModeContainer.style.display = 'none';
                    knnSliderContainer.style.display = 'none';
                }

                // Update highlighting based on toggle state
                if (currentUserUUID) {
                    if (showKnnHighlighting) {
                        updateHighlighting();
                    } else {
                        clearHighlighting();
                    }
                }
            });

            // Handle match mode selection
            matchModeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    matchMode = this.value;

                    // Show/hide KNN slider based on mode
                    if (matchMode === 'group') {
                        knnSliderContainer.style.display = 'none';
                    } else {
                        knnSliderContainer.style.display = 'block';
                    }

                    // Update highlighting if UUID is entered and toggle is on
                    if (currentUserUUID && showKnnHighlighting) {
                        updateHighlighting();
                    }
                });
            });

            // Handle k-slider
            knnSlider.addEventListener('input', function() {
                currentK = parseInt(this.value);
                knnValue.textContent = currentK;
                if (currentUserUUID && showKnnHighlighting) {
                    updateHighlighting();
                }
            });
        }

        // Calculate euclidean distance
        function euclideanDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }

        // Find k nearest neighbors based on cluster X,Y coordinates
        function findKNN(userGroupData, k) {
            if (!userGroupData || !groupsData) return [];

            const userX = parseFloat(userGroupData.X);
            const userY = parseFloat(userGroupData.Y);

            // Calculate distances to all other points
            const distances = groupsData.map((group, idx) => ({
                index: idx,
                uuid: group.UUID,
                distance: euclideanDistance(userX, userY, parseFloat(group.X), parseFloat(group.Y))
            }));

            // Sort by distance and take k nearest (excluding self at distance 0)
            distances.sort((a, b) => a.distance - b.distance);
            return distances.slice(1, k + 1);  // Skip first (self) and take next k
        }

        // Find people in the same group
        function findSameGroup(userGroupData) {
            if (!userGroupData || !groupsData) return [];

            const userGroupId = userGroupData.Optimized_Group_ID;

            // Find all people with the same Optimized_Group_ID (excluding self)
            const sameGroup = groupsData
                .map((group, idx) => ({
                    index: idx,
                    uuid: group.UUID
                }))
                .filter(g => {
                    const groupData = groupsData[g.index];
                    return groupData.Optimized_Group_ID === userGroupId && groupData.UUID !== userGroupData.UUID;
                });

            return sameGroup;
        }

        // Update highlighting based on current UUID and k
        function updateHighlighting() {
            if (!currentUserUUID || !groupsData || !surveyData) return;

            // Find user's group data
            const userGroups = groupsData.filter(g => g.UUID === currentUserUUID);
            if (userGroups.length === 0) {
                document.getElementById('userInfo').style.display = 'none';
                console.log('UUID not found');
                return;
            }

            // Use first matching entry
            const userGroupData = userGroups[0];

            // Find matches based on selected mode
            let matches;
            if (matchMode === 'group') {
                matches = findSameGroup(userGroupData);
            } else {
                matches = findKNN(userGroupData, currentK);
            }

            // Find all UUIDs to highlight (user + matches)
            const uuidsToHighlight = new Set([userGroupData.UUID]);
            matches.forEach(n => uuidsToHighlight.add(n.uuid));

            // Map UUIDs to survey data indices
            highlightedIndices.clear();
            surveyData.forEach((row, idx) => {
                if (uuidsToHighlight.has(row['UUID'])) {
                    highlightedIndices.add(idx);
                }
            });

            // Update user info display
            const matchLabel = matchMode === 'group' ? 'group members' : 'nearest neighbors';
            document.getElementById('userInfo').style.display = 'block';
            document.getElementById('userDetails').innerHTML = `
                <div>Cluster position: (${userGroupData.X}, ${userGroupData.Y})</div>
                <div>Cluster ID: ${userGroupData.Cluster_ID}</div>
                <div>Group ID: ${userGroupData.Optimized_Group_ID}</div>
                <div style="margin-top: 5px;">Showing you + ${highlightedIndices.size - 1} ${matchLabel}</div>
            `;

            // Update charts
            updateChartHighlighting();
            displayHighlightedResponses();
        }

        // Clear highlighting
        function clearHighlighting() {
            highlightedIndices.clear();
            document.getElementById('userInfo').style.display = 'none';
            document.getElementById('responsesSection').style.display = 'none';
            updateChartHighlighting();
        }

        // Update chart colors based on highlighted indices
        function updateChartHighlighting() {
            if (!chart1Instance || !chart2Instance) return;

            // Update chart 1 - intersection points
            const intersections1 = chart1Instance.data.datasets[0].data;
            chart1Instance.data.datasets[0].backgroundColor = intersections1.map((point, idx) => {
                const color = getColorForPoint(point.originalX, point.originalY);
                // Check if any respondent at this intersection is highlighted
                const hasHighlighted = point.respondentIds && point.respondentIds.some(id => highlightedIndices.has(id));
                if (hasHighlighted) {
                    return color.replace(/[\d.]+\)$/, '1.0)');
                }
                return color.replace(/[\d.]+\)$/, '0.6)');
            });
            chart1Instance.data.datasets[0].borderColor = intersections1.map((point, idx) => {
                const hasHighlighted = point.respondentIds && point.respondentIds.some(id => highlightedIndices.has(id));
                if (hasHighlighted) {
                    return 'rgba(255, 215, 0, 1)';
                }
                return getBorderColorForPoint(point.originalX, point.originalY);
            });
            chart1Instance.data.datasets[0].borderWidth = intersections1.map((point, idx) => {
                const hasHighlighted = point.respondentIds && point.respondentIds.some(id => highlightedIndices.has(id));
                return hasHighlighted ? 3 : 1.5;
            });

            // Update chart 2 - intersection points
            const intersections2 = chart2Instance.data.datasets[0].data;
            chart2Instance.data.datasets[0].backgroundColor = intersections2.map((point, idx) => {
                const color = getColorForPoint(point.originalX, point.originalY);
                const hasHighlighted = point.respondentIds && point.respondentIds.some(id => highlightedIndices.has(id));
                if (hasHighlighted) {
                    return color.replace(/[\d.]+\)$/, '1.0)');
                }
                return color.replace(/[\d.]+\)$/, '0.6)');
            });
            chart2Instance.data.datasets[0].borderColor = intersections2.map((point, idx) => {
                const hasHighlighted = point.respondentIds && point.respondentIds.some(id => highlightedIndices.has(id));
                if (hasHighlighted) {
                    return 'rgba(255, 215, 0, 1)';
                }
                return getBorderColorForPoint(point.originalX, point.originalY);
            });
            chart2Instance.data.datasets[0].borderWidth = intersections2.map((point, idx) => {
                const hasHighlighted = point.respondentIds && point.respondentIds.some(id => highlightedIndices.has(id));
                return hasHighlighted ? 3 : 1.5;
            });

            chart1Instance.update('none');
            chart2Instance.update('none');
        }

        function addJitter(value, amount = 0.08) {
            return value + (Math.random() - 0.5) * amount;
        }

        // Aggregate respondents by exact (x,y) intersection
        function aggregateByIntersection(xCol, yCol, categories) {
            const intersections = {};

            surveyData.forEach((row, idx) => {
                const x = parseFloat(row[xCol]);
                const y = parseFloat(row[yCol]);

                if (!isNaN(x) && !isNaN(y)) {
                    const key = `${x},${y}`;

                    if (!intersections[key]) {
                        intersections[key] = {
                            x: x,
                            y: y,
                            count: 0,
                            respondentIds: [],
                            categoryBreakdown: {}  // For each category column, track value counts
                        };

                        // Initialize category breakdown
                        categories.forEach(cat => {
                            intersections[key].categoryBreakdown[cat.col] = {};
                        });
                    }

                    intersections[key].count++;
                    intersections[key].respondentIds.push(idx);

                    // Track category values for this respondent
                    categories.forEach(cat => {
                        const catValue = row[cat.col];
                        if (catValue && catValue.trim() !== '') {
                            if (!intersections[key].categoryBreakdown[cat.col][catValue]) {
                                intersections[key].categoryBreakdown[cat.col][catValue] = {
                                    count: 0,
                                    respondentIds: []
                                };
                            }
                            intersections[key].categoryBreakdown[cat.col][catValue].count++;
                            intersections[key].categoryBreakdown[cat.col][catValue].respondentIds.push(idx);
                        }
                    });
                }
            });

            return Object.values(intersections);
        }

        function processIndividualRespondents(xCol, yCol, categories) {
            const individuals = [];

            surveyData.forEach((row, idx) => {
                const x = parseFloat(row[xCol]);
                const y = parseFloat(row[yCol]);

                if (!isNaN(x) && !isNaN(y)) {
                    const categoryValues = {};
                    categories.forEach(cat => {
                        categoryValues[cat.col] = row[cat.col];
                    });

                    individuals.push({
                        x: addJitter(x),
                        y: addJitter(y),
                        originalX: x,
                        originalY: y,
                        categories: categoryValues,
                        respondentId: idx
                    });
                }
            });

            return individuals;
        }

        function processCategory(categoryCol, xCol, yCol, minCount) {
            const groups = {};

            surveyData.forEach(row => {
                const value = row[categoryCol];
                if (!value || value.trim() === '') return;

                if (!groups[value]) {
                    groups[value] = {
                        xScores: [],
                        yScores: []
                    };
                }

                const x = parseFloat(row[xCol]);
                const y = parseFloat(row[yCol]);

                if (!isNaN(x)) groups[value].xScores.push(x);
                if (!isNaN(y)) groups[value].yScores.push(y);
            });

            const result = [];
            for (const [label, data] of Object.entries(groups)) {
                if (data.xScores.length >= minCount && data.yScores.length >= minCount) {
                    const avgX = data.xScores.reduce((a, b) => a + b, 0) / data.xScores.length;
                    const avgY = data.yScores.reduce((a, b) => a + b, 0) / data.yScores.length;

                    result.push({
                        label: label,
                        x: avgX,
                        y: avgY,
                        invertedY: 6 - avgY,
                        count: data.xScores.length
                    });
                }
            }

            return result;
        }

        function getColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            const xNorm = (x - 1) / 4;
            const alphaNorm = Math.pow(xNorm, 2);
            const alpha = 0.25 + (alphaNorm * 0.75);

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getBorderColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getHoverColorForPoint(x, y) {
            const yNorm = (y - 1) / 4;
            let r, g, b;

            if (yNorm < 0.5) {
                const t = yNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (yNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgba(${r}, ${g}, ${b}, 1.0)`;
        }

        function calculateVisibleLabels(allData, visibleSet) {
            visibleSet.clear();

            if (!allData || allData.length === 0) return;

            const centerX = 3;
            const centerY = 3;

            const quadrants = {
                topLeft: [],
                topRight: [],
                bottomLeft: [],
                bottomRight: []
            };

            allData.forEach((d, i) => {
                const point = {
                    index: i,
                    x: d.x,
                    y: d.y,
                    count: d.count,
                    label: d.label
                };

                if (d.x < centerX && d.y < centerY) {
                    quadrants.topLeft.push(point);
                } else if (d.x >= centerX && d.y < centerY) {
                    quadrants.topRight.push(point);
                } else if (d.x < centerX && d.y >= centerY) {
                    quadrants.bottomLeft.push(point);
                } else {
                    quadrants.bottomRight.push(point);
                }
            });

            Object.keys(quadrants).forEach(key => {
                quadrants[key].sort((a, b) => b.count - a.count);
            });

            const threshold = collisionThreshold;
            const shownLabels = [];

            const addFromQuadrant = (points, maxFromQuadrant) => {
                let added = 0;
                for (let candidate of points) {
                    if (added >= maxFromQuadrant) break;

                    let hasCollision = false;
                    for (let shown of shownLabels) {
                        const distance = Math.sqrt(
                            Math.pow(candidate.x - shown.x, 2) +
                            Math.pow(candidate.y - shown.y, 2)
                        );
                        if (distance < threshold) {
                            hasCollision = true;
                            break;
                        }
                    }

                    if (!hasCollision) {
                        shownLabels.push(candidate);
                        visibleSet.add(candidate.index);
                        added++;
                    }
                }
            };

            addFromQuadrant(quadrants.topLeft, 2);
            addFromQuadrant(quadrants.topRight, 2);
            addFromQuadrant(quadrants.bottomLeft, 2);
            addFromQuadrant(quadrants.bottomRight, 2);

            const allRemaining = [
                ...quadrants.topLeft,
                ...quadrants.topRight,
                ...quadrants.bottomLeft,
                ...quadrants.bottomRight
            ].filter(p => !visibleSet.has(p.index))
             .sort((a, b) => b.count - a.count);

            for (let candidate of allRemaining) {
                if (shownLabels.length >= 25) break;

                let hasCollision = false;
                for (let shown of shownLabels) {
                    const distance = Math.sqrt(
                        Math.pow(candidate.x - shown.x, 2) +
                        Math.pow(candidate.y - shown.y, 2)
                    );
                    if (distance < threshold) {
                        hasCollision = true;
                        break;
                    }
                }

                if (!hasCollision) {
                    shownLabels.push(candidate);
                    visibleSet.add(candidate.index);
                }
            }
        }

        // Chart.js plugin to draw connection lines from intersections to categories
        const connectionLinesPlugin = {
            id: 'connectionLines',
            afterDatasetsDraw(chart, args, options) {
                const ctx = chart.ctx;
                const isChart1 = chart.canvas.id === 'compassChart1';

                // Get hover state for this chart
                const hoveredIntersection = isChart1 ? hoveredChart1Intersection : hoveredChart2Intersection;
                const hoveredCategory = isChart1 ? hoveredChart1Category : hoveredChart2Category;

                // Get datasets
                const intersectionDataset = chart.data.datasets[0];
                const categoryDataset = chart.data.datasets[1];

                if (!intersectionDataset || !categoryDataset) return;

                // Get intersections data
                const intersections = isChart1 ? window.chart1Intersections : window.chart2Intersections;
                if (!intersections) return;

                const intMeta = chart.getDatasetMeta(0);
                const catMeta = chart.getDatasetMeta(1);

                ctx.save();

                // CASE 1: Hovering over an intersection - show lines to categories
                if (hoveredIntersection) {
                    const intersection = intersections[hoveredIntersection.index];
                    if (!intersection) return;

                    const intElement = intMeta.data[hoveredIntersection.index];
                    if (!intElement) return;

                    const intX = intElement.x;
                    const intY = intElement.y;

                    // Draw lines to all categories that people at this intersection chose
                    Object.entries(intersection.categoryBreakdown).forEach(([catCol, catValues]) => {
                        Object.entries(catValues).forEach(([catValue, catData]) => {
                            const catIndex = categoryDataset.data.findIndex(d => d.categoryLabel === catValue);
                            if (catIndex === -1) return;

                            const catElement = catMeta.data[catIndex];
                            if (!catElement) return;

                            const lineWidth = Math.max(1, Math.min(10, catData.count * 1.5));

                            ctx.beginPath();
                            ctx.moveTo(intX, intY);
                            ctx.lineTo(catElement.x, catElement.y);
                            ctx.strokeStyle = 'rgba(100, 150, 200, 0.5)';
                            ctx.lineWidth = lineWidth;
                            ctx.stroke();
                        });
                    });
                }

                // CASE 2: Hovering over a category - show lines to intersections
                if (hoveredCategory) {
                    const catElement = catMeta.data[hoveredCategory.index];
                    if (!catElement) return;

                    const catX = catElement.x;
                    const catY = catElement.y;
                    const categoryLabel = categoryDataset.data[hoveredCategory.index].categoryLabel;

                    // For each intersection, check if anyone chose this category
                    intersections.forEach((intersection, intIndex) => {
                        let totalCount = 0;

                        // Count people at this intersection who chose this category
                        Object.entries(intersection.categoryBreakdown).forEach(([catCol, catValues]) => {
                            if (catValues[categoryLabel]) {
                                totalCount += catValues[categoryLabel].count;
                            }
                        });

                        if (totalCount > 0) {
                            const intElement = intMeta.data[intIndex];
                            if (!intElement) return;

                            const lineWidth = Math.max(1, Math.min(10, totalCount * 1.5));

                            ctx.beginPath();
                            ctx.moveTo(catX, catY);
                            ctx.lineTo(intElement.x, intElement.y);
                            ctx.strokeStyle = 'rgba(100, 150, 200, 0.5)';
                            ctx.lineWidth = lineWidth;
                            ctx.stroke();
                        }
                    });
                }

                ctx.restore();
            }
        };

        function createCompassChart1() {
            const canvas = document.getElementById('compassChart1');
            const ctx = canvas.getContext('2d');

            let rawData = [
                ...processedData.dinner,
                ...processedData.workplace,
                ...processedData.podcast
            ];

            // Create allData with y set to invertedY for collision detection
            let allData = rawData.map(d => ({
                ...d,
                displayY: d.invertedY,
                y: d.invertedY  // For collision detection
            }));

            const minVal = 1;
            const maxVal = 5;

            calculateVisibleLabels(allData, visibleLabelIndices1);

            // Aggregate respondents by intersection
            const intersections = aggregateByIntersection(
                'I believe AGI is likely within the next 10 years.',
                'We should slow down AI progress until safety is better understood.',
                [
                    {col: 'Who would you most want to have dinner with?'},
                    {col: 'I would most want to work at:'},
                    {col: 'What is your favorite ML related podcast?'}
                ]
            );

            // Store for drawing lines later
            window.chart1Intersections = intersections;

            // Create intersection points dataset
            const intersectionDataset = {
                label: 'Intersection Points',
                data: intersections.map(int => ({
                    x: int.x,
                    y: 6 - int.y,  // Invert Y for display
                    originalX: int.x,
                    originalY: int.y,
                    count: int.count,
                    respondentIds: int.respondentIds,
                    categoryBreakdown: int.categoryBreakdown
                })),
                backgroundColor: intersections.map(int => {
                    // Check if any respondent at this intersection is highlighted
                    const hasHighlighted = int.respondentIds.some(id => highlightedIndices.has(id));
                    const color = getColorForPoint(int.x, int.y);
                    return hasHighlighted ? color.replace(/[\d.]+\)$/, '1.0)') : color.replace(/[\d.]+\)$/, '0.6)');
                }),
                borderColor: intersections.map(int => {
                    const hasHighlighted = int.respondentIds.some(id => highlightedIndices.has(id));
                    return hasHighlighted ? 'rgba(255, 215, 0, 1)' : getBorderColorForPoint(int.x, int.y);
                }),
                borderWidth: intersections.map(int => {
                    const hasHighlighted = int.respondentIds.some(id => highlightedIndices.has(id));
                    return hasHighlighted ? 3 : 1.5;
                }),
                pointRadius: intersections.map(int => Math.max(6, Math.sqrt(int.count) * 2.5)),
                pointHoverRadius: intersections.map(int => Math.max(7, Math.sqrt(int.count) * 2.7)),
                pointStyle: 'circle',
                hitRadius: 8,
                order: 2,
                datalabels: {
                    display: true,
                    color: '#000',
                    font: { size: 10, weight: 'bold' },
                    formatter: function(value) {
                        return value.count;
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.8)',
                    borderRadius: 3,
                    padding: 2
                }
            };

            // Create category averages dataset
            const categoryDataset = {
                label: 'Category Averages',
                order: 1,  // Draw category points last (on top of individuals)
                data: allData.map(d => ({
                    x: d.x,
                    y: d.displayY,
                    label: d.label,
                    count: d.count,
                    xVal: d.x,
                    yVal: 6 - d.displayY,  // Convert back to original safety value
                    categoryLabel: d.label
                })),
                backgroundColor: rawData.map(d => getColorForPoint(d.x, d.y)),
                borderColor: rawData.map(d => getBorderColorForPoint(d.x, d.y)),
                borderWidth: 1.5,
                pointRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverBackgroundColor: rawData.map(d => getHoverColorForPoint(d.x, d.y)),
                pointHoverBorderColor: rawData.map(d => getBorderColorForPoint(d.x, d.y)),
                pointHoverBorderWidth: 2.5,
            };

            chart1Instance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [intersectionDataset, categoryDataset] },
                plugins: [connectionLinesPlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `${point.label}`,
                                        `AGI Timeline: ${point.xVal.toFixed(2)}/5`,
                                        `Safety Priority: ${point.yVal.toFixed(2)}/5`,
                                        `Responses: ${point.count}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // Show if: hovered, in default visible set, or in hover-forced set
                                if (hoveredCategoryLabelsToShow1.size > 0) {
                                    return hoveredCategoryLabelsToShow1.has(context.dataIndex);
                                }
                                return context.hovered || visibleLabelIndices1.has(context.dataIndex);
                            },
                            align: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                const mid = (minVal + maxVal) / 2;
                                if (point.x > mid && point.y < mid) return 'right';
                                if (point.x < mid && point.y < mid) return 'left';
                                if (point.x > mid && point.y > mid) return 'right';
                                return 'left';
                            },
                            offset: 6,
                            color: '#000',
                            font: { size: 9, weight: '600', family: 'Arial, sans-serif' },
                            formatter: function(value) {
                                const label = value.label;
                                return label.length > 18 ? label.substring(0, 16) + '...' : label;
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: function(context) {
                                return context.hovered ? '#000' : '#999';
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 4
                        }
                    },
                    onHover: function(event, activeElements) {
                        if (activeElements.length > 0) {
                            const element = activeElements[0];
                            const datasetIndex = element.datasetIndex;
                            const dataIndex = element.index;

                            // Hovering intersection (dataset 0)
                            if (datasetIndex === 0) {
                                hoveredChart1Intersection = {index: dataIndex, data: intersections[dataIndex]};
                                hoveredChart1Category = null;
                            }
                            // Hovering category (dataset 1)
                            else if (datasetIndex === 1) {
                                hoveredChart1Category = {index: dataIndex, data: categoryDataset.data[dataIndex]};
                                hoveredChart1Intersection = null;
                            }

                            chart1Instance.update('none');
                        } else {
                            // Not hovering anything
                            hoveredChart1Intersection = null;
                            hoveredChart1Category = null;
                            chart1Instance.update('none');
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'AGI Likely Within 10 Years →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: 0.85,
                            max: 5.15,
                            ticks: {
                                stepSize: 1,
                                autoSkip: false,
                                callback: function(value) {
                                    // Only show integer ticks from 1-5
                                    if (Number.isInteger(value) && value >= 1 && value <= 5) {
                                        return value;
                                    }
                                    return null;  // Hide non-integer or out-of-range ticks
                                }
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '← Prioritize AI Safety (Inverted)',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: 0.85,
                            max: 5.15,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return 6 - value;
                                }
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels, connectionLinesPlugin]
            });
        }

        function createCompassChart2() {
            const canvas = document.getElementById('compassChart2');
            const ctx = canvas.getContext('2d');

            let allData = [
                ...processedData2.dinner,
                ...processedData2.workplace,
                ...processedData2.podcast
            ];

            const minVal = 1;
            const maxVal = 5;

            calculateVisibleLabels(allData, visibleLabelIndices2);

            // Aggregate respondents by intersection for second compass
            const intersections = aggregateByIntersection(
                "I'd rather build a working prototype than write a perfect paper.",
                "I believe creativity is more important than rigor in research.",
                [
                    {col: 'Who would you most want to have dinner with?'},
                    {col: 'I would most want to work at:'},
                    {col: 'What is your favorite ML related podcast?'}
                ]
            );

            // Store for drawing lines later
            window.chart2Intersections = intersections;

            // Create intersection points dataset
            const intersectionDataset = {
                label: 'Intersection Points',
                data: intersections.map(int => ({
                    x: int.x,
                    y: int.y,  // No inversion for second chart
                    originalX: int.x,
                    originalY: int.y,
                    count: int.count,
                    respondentIds: int.respondentIds,
                    categoryBreakdown: int.categoryBreakdown
                })),
                backgroundColor: intersections.map(int => {
                    const hasHighlighted = int.respondentIds.some(id => highlightedIndices.has(id));
                    const color = getColorForPoint(int.x, int.y);
                    return hasHighlighted ? color.replace(/[\d.]+\)$/, '1.0)') : color.replace(/[\d.]+\)$/, '0.6)');
                }),
                borderColor: intersections.map(int => {
                    const hasHighlighted = int.respondentIds.some(id => highlightedIndices.has(id));
                    return hasHighlighted ? 'rgba(255, 215, 0, 1)' : getBorderColorForPoint(int.x, int.y);
                }),
                borderWidth: intersections.map(int => {
                    const hasHighlighted = int.respondentIds.some(id => highlightedIndices.has(id));
                    return hasHighlighted ? 3 : 1.5;
                }),
                pointRadius: intersections.map(int => Math.max(6, Math.sqrt(int.count) * 2.5)),
                pointHoverRadius: intersections.map(int => Math.max(7, Math.sqrt(int.count) * 2.7)),
                pointStyle: 'circle',
                hitRadius: 8,
                order: 2,
                datalabels: {
                    display: true,
                    color: '#000',
                    font: { size: 10, weight: 'bold' },
                    formatter: function(value) {
                        return value.count;
                    },
                    backgroundColor: 'rgba(255, 255, 255, 0.8)',
                    borderRadius: 3,
                    padding: 2
                }
            };

            // Create category averages dataset
            const categoryDataset = {
                label: 'Category Averages',
                order: 1,  // Draw category points last (on top of individuals)
                data: allData.map(d => ({
                    x: d.x,
                    y: d.y,  // Use regular Y, not inverted
                    label: d.label,
                    count: d.count,
                    xVal: d.x,
                    yVal: d.y,
                    categoryLabel: d.label
                })),
                backgroundColor: allData.map(d => getColorForPoint(d.x, d.y)),
                borderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                borderWidth: 1.5,
                pointRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverBackgroundColor: allData.map(d => getHoverColorForPoint(d.x, d.y)),
                pointHoverBorderColor: allData.map(d => getBorderColorForPoint(d.x, d.y)),
                pointHoverBorderWidth: 2.5,
            };

            chart2Instance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [intersectionDataset, categoryDataset] },
                plugins: [connectionLinesPlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `${point.label}`,
                                        `Prototype vs Paper: ${point.xVal.toFixed(2)}/5`,
                                        `Creativity vs Rigor: ${point.yVal.toFixed(2)}/5`,
                                        `Responses: ${point.count}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                // Show if: hovered, in default visible set, or in hover-forced set
                                if (hoveredCategoryLabelsToShow2.size > 0) {
                                    return hoveredCategoryLabelsToShow2.has(context.dataIndex);
                                }
                                return context.hovered || visibleLabelIndices2.has(context.dataIndex);
                            },
                            align: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                const mid = (minVal + maxVal) / 2;
                                if (point.x > mid && point.y < mid) return 'right';
                                if (point.x < mid && point.y < mid) return 'left';
                                if (point.x > mid && point.y > mid) return 'right';
                                return 'left';
                            },
                            offset: 6,
                            color: '#000',
                            font: { size: 9, weight: '600', family: 'Arial, sans-serif' },
                            formatter: function(value) {
                                const label = value.label;
                                return label.length > 18 ? label.substring(0, 16) + '...' : label;
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: function(context) {
                                return context.hovered ? '#000' : '#999';
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 4
                        }
                    },
                    onHover: function(event, activeElements) {
                        if (activeElements.length > 0) {
                            const element = activeElements[0];
                            const datasetIndex = element.datasetIndex;
                            const dataIndex = element.index;

                            // Hovering intersection (dataset 0)
                            if (datasetIndex === 0) {
                                hoveredChart2Intersection = {index: dataIndex, data: intersections[dataIndex]};
                                hoveredChart2Category = null;
                            }
                            // Hovering category (dataset 1)
                            else if (datasetIndex === 1) {
                                hoveredChart2Category = {index: dataIndex, data: categoryDataset.data[dataIndex]};
                                hoveredChart2Intersection = null;
                            }

                            chart2Instance.update('none');
                        } else {
                            // Not hovering anything
                            hoveredChart2Intersection = null;
                            hoveredChart2Category = null;
                            chart2Instance.update('none');
                        }
                    },



























































































































                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Prefer Prototypes Over Papers →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: 0.85,
                            max: 5.15,
                            ticks: {
                                stepSize: 1,
                                autoSkip: false,
                                callback: function(value) {
                                    // Only show integer ticks from 1-5
                                    if (Number.isInteger(value) && value >= 1 && value <= 5) {
                                        return value;
                                    }
                                    return null;  // Hide non-integer or out-of-range ticks
                                }
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Creativity Over Rigor →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: 0.85,
                            max: 5.15,
                            ticks: {
                                stepSize: 1
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels, connectionLinesPlugin]
            });
        }

        function createPieCharts() {
            // Dinner pie chart
            const dinnerCounts = {};
            surveyData.forEach(row => {
                const value = row['Who would you most want to have dinner with?'];
                if (value && value.trim() !== '') {
                    dinnerCounts[value] = (dinnerCounts[value] || 0) + 1;
                }
            });
            const dinnerEntries = Object.entries(dinnerCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

            new Chart(document.getElementById('dinnerPieChart'), {
                type: 'pie',
                data: {
                    labels: dinnerEntries.map(d => d[0]),
                    datasets: [{
                        data: dinnerEntries.map(d => d[1]),
                        backgroundColor: generateColors(dinnerEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                if (percentage < 5) return '';  // Hide small slices
                                return label + '\n' + percentage + '%';
                            },
                            align: 'start',
                            anchor: 'end',
                            offset: 4,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 3,
                            clamp: true
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            // Workplace pie chart
            const workplaceCounts = {};
            surveyData.forEach(row => {
                const value = row['I would most want to work at:'];
                if (value && value.trim() !== '') {
                    workplaceCounts[value] = (workplaceCounts[value] || 0) + 1;
                }
            });
            const workplaceEntries = Object.entries(workplaceCounts).sort((a, b) => b[1] - a[1]);

            new Chart(document.getElementById('workplacePieChart'), {
                type: 'pie',
                data: {
                    labels: workplaceEntries.map(d => d[0]),
                    datasets: [{
                        data: workplaceEntries.map(d => d[1]),
                        backgroundColor: generateColors(workplaceEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                if (percentage < 5) return '';  // Hide small slices
                                return label + '\n' + percentage + '%';
                            },
                            align: 'start',
                            anchor: 'end',
                            offset: 4,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 3,
                            clamp: true
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            // Podcast pie chart
            const podcastCounts = {};
            surveyData.forEach(row => {
                const value = row['What is your favorite ML related podcast?'];
                if (value && value.trim() !== '') {
                    podcastCounts[value] = (podcastCounts[value] || 0) + 1;
                }
            });
            const podcastEntries = Object.entries(podcastCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

            new Chart(document.getElementById('podcastPieChart'), {
                type: 'pie',
                data: {
                    labels: podcastEntries.map(d => d[0]),
                    datasets: [{
                        data: podcastEntries.map(d => d[1]),
                        backgroundColor: generateColors(podcastEntries.length)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                size: 9,
                                weight: 'bold'
                            },
                            formatter: function(value, context) {
                                const label = context.chart.data.labels[context.dataIndex];
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(0);
                                if (percentage < 5) return '';  // Hide small slices
                                return label + '\n' + percentage + '%';
                            },
                            align: 'start',
                            anchor: 'end',
                            offset: 4,
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            borderRadius: 3,
                            padding: 3,
                            clamp: true
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                colors.push(`hsl(${hue}, 60%, 60%)`);
            }
            return colors;
        }


        // Display responses for highlighted users
        function displayHighlightedResponses() {
            const section = document.getElementById('responsesSection');
            const content = document.getElementById('responsesContent');

            if (highlightedIndices.size === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';

            // Get the highlighted respondents
            const highlighted = Array.from(highlightedIndices).map(idx => surveyData[idx]);

            // Separate user from neighbors
            const userUUID = currentUserUUID;
            const user = highlighted.find(r => r.UUID === userUUID);
            const others = highlighted.filter(r => r.UUID !== userUUID);
            const otherLabel = matchMode === 'group' ? 'Group Member' : 'Neighbor';

            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">';

            // Show user's responses
            if (user) {
                html += '<div style="background: white; padding: 15px; border-radius: 8px; border: 3px solid gold;">';
                html += '<h3 style="margin-top: 0; color: goldenrod;">You</h3>';
                html += formatResponses(user);
                html += '</div>';
            }

            // Show neighbors' or group members' responses
            others.slice(0, 5).forEach((other, idx) => {
                html += '<div style="background: white; padding: 15px; border-radius: 8px; border: 1px solid #ddd;">';
                html += `<h3 style="margin-top: 0; color: #666;">${otherLabel} ${idx + 1}</h3>`;
                html += formatResponses(other);
                html += '</div>';
            });

            html += '</div>';
            content.innerHTML = html;
        }

        // Format survey responses for display
        function formatResponses(respondent) {
            let html = '<div style="font-size: 13px; line-height: 1.6;">';

            // Show key questions
            const keyQuestions = [
                'Who would you most want to have dinner with?',
                'I would most want to work at:',
                'What is your favorite ML related podcast?',
                'I believe AGI is likely within the next 10 years.',
                'We should slow down AI progress until safety is better understood.',
                'I\'d rather build a working prototype than write a perfect paper.',
                'I believe creativity is more important than rigor in research.'
            ];

            keyQuestions.forEach(q => {
                const answer = respondent[q];
                if (answer) {
                    html += `<div style="margin-bottom: 10px;">`;
                    html += `<strong style="color: #555;">${q.substring(0, 60)}${q.length > 60 ? '...' : ''}</strong><br>`;
                    html += `<span style="color: #333;">${answer}</span>`;
                    html += `</div>`;
                }
            });

            html += '</div>';
            return html;
        }
    </script>
</body>
</html>
