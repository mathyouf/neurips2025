<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeurIPS Twin Survey 2025 - Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', Times, serif;
            background: #ffffff;
            color: #000;
            line-height: 1.6;
            padding: 40px 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #000;
        }

        .authors {
            font-size: 1.1em;
            margin-bottom: 10px;
            font-style: italic;
        }

        .affiliation {
            font-size: 0.95em;
            color: #333;
            margin-bottom: 20px;
        }

        .abstract {
            max-width: 900px;
            margin: 20px auto;
            text-align: justify;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .abstract strong {
            font-weight: bold;
        }

        h2 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 40px 0 20px 0;
            color: #000;
        }

        h3 {
            font-size: 1.2em;
            font-weight: bold;
            margin: 30px 0 15px 0;
            color: #000;
        }

        .section {
            margin: 40px 0;
        }

        .compass-section {
            margin: 40px 0;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 30px auto;
            aspect-ratio: 1 / 1;
        }

        .figure-caption {
            text-align: center;
            font-size: 0.9em;
            margin: 15px auto 0;
            max-width: 800px;
            color: #333;
        }

        .figure-caption strong {
            font-weight: bold;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: #f9f9f9;
            padding: 20px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #000;
            margin: 10px 0;
            font-family: 'Times New Roman', Times, serif;
        }

        .stat-label {
            color: #333;
            font-size: 0.9em;
        }

        .charts-container {
            margin: 40px 0;
        }

        .chart-wrapper {
            margin: 40px 0;
            padding: 20px;
            background: #f9f9f9;
            border: 1px solid #ddd;
        }

        .chart-title {
            font-size: 1.1em;
            margin-bottom: 20px;
            color: #000;
            font-weight: bold;
        }

        .chart-canvas {
            max-height: 400px;
        }

        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: #666;
        }

        .insights {
            background: #f9f9f9;
            padding: 25px;
            margin: 30px 0;
            border-left: 3px solid #000;
        }

        .insights h3 {
            margin-top: 0;
        }

        .insights ul {
            list-style-position: inside;
            line-height: 1.8;
        }

        footer {
            margin-top: 60px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
            text-align: center;
            font-size: 0.85em;
            color: #666;
        }

        footer a {
            color: #000;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NeurIPS Twin Survey 2025: Understanding AI Researcher Perspectives</h1>
            <div class="authors">Anonymous Authors</div>
            <div class="affiliation">NeurIPS 2025</div>
            <div class="abstract">
                <strong>Abstract.</strong> We present an analysis of survey data (N=335) collected from AI researchers
                attending NeurIPS 2025. The survey captures perspectives on AGI timelines, AI safety concerns,
                workplace preferences, and research methodologies. We visualize the relationship between AGI timeline
                beliefs and AI safety priorities using a two-dimensional political compass, revealing distinct clusters
                of researcher perspectives. Each point represents the average position of researchers who selected a
                specific categorical response (dinner companion, workplace, or podcast preference), with color encoding
                safety priority (blue = accelerate, red = slow down) and opacity encoding AGI timeline belief strength.
            </div>
        </header>

        <div id="loading" class="loading">Loading survey data...</div>

        <div id="content" style="display: none;">
            <section class="section compass-section">
                <h2>1. Political Compass: AGI Beliefs vs. Safety Priorities</h2>
                <div class="chart-container">
                    <canvas id="compassChart"></canvas>
                </div>
                <div class="figure-caption">
                    <strong>Figure 1:</strong> Political compass mapping AI researcher positions based on AGI timeline
                    beliefs (X-axis, 1-5 Likert scale) and AI safety priorities (Y-axis, inverted 1-5 scale). Each point
                    represents the average position of researchers sharing a categorical preference. Color indicates
                    safety priority through a blue-white-red gradient (blue = move fast, red = prioritize safety).
                    Opacity encodes AGI timeline belief strength (faint = skeptical, solid = believer). Points are sized
                    by response count.
                </div>
            </section>

            <section class="section">
                <h2>2. Summary Statistics</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Total Responses</div>
                        <div class="stat-value" id="totalResponses">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">AGI Belief (avg)</div>
                        <div class="stat-value" id="agiAvg">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Safety Concern (avg)</div>
                        <div class="stat-value" id="safetyAvg">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Top Workplace</div>
                        <div class="stat-value" id="topWorkplace" style="font-size: 1.1em;">-</div>
                    </div>
                </div>

                <div class="insights">
                    <h3>Key Findings</h3>
                    <ul id="insightsList"></ul>
                </div>
            </section>

            <section class="section">
                <h2>3. Detailed Response Distributions</h2>

                <div class="charts-container">
                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.1 Dream Dinner Companions (Top 10)</h3>
                        <canvas id="dinnerChart" class="chart-canvas"></canvas>
                    </div>

                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.2 AGI Likelihood Beliefs (1-5 Scale)</h3>
                        <canvas id="agiChart" class="chart-canvas"></canvas>
                    </div>

                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.3 Preferred Workplace</h3>
                        <canvas id="workplaceChart" class="chart-canvas"></canvas>
                    </div>

                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.4 Research Style Distribution</h3>
                        <canvas id="researchStyleChart" class="chart-canvas"></canvas>
                    </div>

                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.5 Model Training Style</h3>
                        <canvas id="trainingStyleChart" class="chart-canvas"></canvas>
                    </div>

                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.6 AI Safety: Should We Slow Down? (1-5)</h3>
                        <canvas id="safetyChart" class="chart-canvas"></canvas>
                    </div>

                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.7 Favorite ML Podcasts (Top 8)</h3>
                        <canvas id="podcastChart" class="chart-canvas"></canvas>
                    </div>

                    <div class="chart-wrapper">
                        <h3 class="chart-title">3.8 Primary Bottleneck in AI</h3>
                        <canvas id="bottleneckChart" class="chart-canvas"></canvas>
                    </div>
                </div>
            </section>
        </div>

        <footer>
            <p>NeurIPS Twin Survey 2025 | <a href="https://github.com/mathyouf/neurips2025">View on GitHub</a></p>
        </footer>
    </div>

    <script>
        let surveyData = null;
        let processedData = {
            dinner: [],
            workplace: [],
            podcast: []
        };
        const collisionThreshold = 0.2; // Fixed threshold
        let visibleLabelIndices = new Set();

        // Load and parse CSV data
        Papa.parse('neuripstwin7.csv', {
            download: true,
            header: true,
            complete: function(results) {
                surveyData = results.data.filter(row => row.Timestamp && row.Timestamp.trim() !== '');
                console.log('Loaded', surveyData.length, 'responses');

                // Process compass data
                processedData.dinner = processCategory('Who would you most want to have dinner with?', 3);
                processedData.workplace = processCategory('I would most want to work at:', 3);
                processedData.podcast = processCategory('What is your favorite ML related podcast?', 5);

                // Hide loading, show content
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                // Create compass chart
                createCompassChart();

                // Create other visualizations
                createVisualizations(surveyData);
            },
            error: function(error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 'Error loading data. Please check the console.';
            }
        });

        function processCategory(columnName, minCount) {
            const agiCol = 'I believe AGI is likely within the next 10 years.';
            const safetyCol = 'We should slow down AI progress until safety is better understood.';

            const groups = {};

            surveyData.forEach(row => {
                const value = row[columnName];
                if (!value || value.trim() === '') return;

                if (!groups[value]) {
                    groups[value] = {
                        agiScores: [],
                        safetyScores: []
                    };
                }

                const agi = parseFloat(row[agiCol]);
                const safety = parseFloat(row[safetyCol]);

                if (!isNaN(agi)) groups[value].agiScores.push(agi);
                if (!isNaN(safety)) groups[value].safetyScores.push(safety);
            });

            const result = [];
            for (const [label, data] of Object.entries(groups)) {
                if (data.agiScores.length >= minCount && data.safetyScores.length >= minCount) {
                    const avgAgi = data.agiScores.reduce((a, b) => a + b, 0) / data.agiScores.length;
                    const avgSafety = data.safetyScores.reduce((a, b) => a + b, 0) / data.safetyScores.length;

                    result.push({
                        label: label,
                        agi: avgAgi,
                        safety: avgSafety,
                        invertedSafety: 6 - avgSafety,
                        count: data.agiScores.length
                    });
                }
            }

            return result;
        }

        function getColorForPoint(agi, safety) {
            const safetyNorm = (safety - 1) / 4;
            let r, g, b;

            if (safetyNorm < 0.5) {
                const t = safetyNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (safetyNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            const agiNorm = (agi - 1) / 4;
            const alphaNorm = Math.pow(agiNorm, 2);
            const alpha = 0.25 + (alphaNorm * 0.75);

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getBorderColorForPoint(agi, safety) {
            const safetyNorm = (safety - 1) / 4;
            let r, g, b;

            if (safetyNorm < 0.5) {
                const t = safetyNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (safetyNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        function getHoverColorForPoint(agi, safety) {
            const safetyNorm = (safety - 1) / 4;
            let r, g, b;

            if (safetyNorm < 0.5) {
                const t = safetyNorm * 2;
                r = Math.round(59 + (255 - 59) * t);
                g = Math.round(130 + (255 - 130) * t);
                b = Math.round(246 + (255 - 246) * t);
            } else {
                const t = (safetyNorm - 0.5) * 2;
                r = Math.round(255 + (220 - 255) * t);
                g = Math.round(255 + (20 - 255) * t);
                b = Math.round(255 + (20 - 255) * t);
            }

            return `rgba(${r}, ${g}, ${b}, 1.0)`;
        }

        function calculateVisibleLabels(allData) {
            visibleLabelIndices.clear();

            if (!allData || allData.length === 0) return;

            const centerX = 3;
            const centerY = 3;

            const quadrants = {
                topLeft: [],
                topRight: [],
                bottomLeft: [],
                bottomRight: []
            };

            allData.forEach((d, i) => {
                const point = {
                    index: i,
                    agi: d.agi,
                    safety: d.invertedSafety,
                    count: d.count,
                    label: d.label
                };

                if (d.agi < centerX && d.invertedSafety < centerY) {
                    quadrants.topLeft.push(point);
                } else if (d.agi >= centerX && d.invertedSafety < centerY) {
                    quadrants.topRight.push(point);
                } else if (d.agi < centerX && d.invertedSafety >= centerY) {
                    quadrants.bottomLeft.push(point);
                } else {
                    quadrants.bottomRight.push(point);
                }
            });

            Object.keys(quadrants).forEach(key => {
                quadrants[key].sort((a, b) => b.count - a.count);
            });

            const threshold = collisionThreshold;
            const shownLabels = [];

            const addFromQuadrant = (points, maxFromQuadrant) => {
                let added = 0;
                for (let candidate of points) {
                    if (added >= maxFromQuadrant) break;

                    let hasCollision = false;
                    for (let shown of shownLabels) {
                        const distance = Math.sqrt(
                            Math.pow(candidate.agi - shown.agi, 2) +
                            Math.pow(candidate.safety - shown.safety, 2)
                        );
                        if (distance < threshold) {
                            hasCollision = true;
                            break;
                        }
                    }

                    if (!hasCollision) {
                        shownLabels.push(candidate);
                        visibleLabelIndices.add(candidate.index);
                        added++;
                    }
                }
            };

            addFromQuadrant(quadrants.topLeft, 2);
            addFromQuadrant(quadrants.topRight, 2);
            addFromQuadrant(quadrants.bottomLeft, 2);
            addFromQuadrant(quadrants.bottomRight, 2);

            const allRemaining = [
                ...quadrants.topLeft,
                ...quadrants.topRight,
                ...quadrants.bottomLeft,
                ...quadrants.bottomRight
            ].filter(p => !visibleLabelIndices.has(p.index))
             .sort((a, b) => b.count - a.count);

            for (let candidate of allRemaining) {
                if (shownLabels.length >= 25) break;

                let hasCollision = false;
                for (let shown of shownLabels) {
                    const distance = Math.sqrt(
                        Math.pow(candidate.agi - shown.agi, 2) +
                        Math.pow(candidate.safety - shown.safety, 2)
                    );
                    if (distance < threshold) {
                        hasCollision = true;
                        break;
                    }
                }

                if (!hasCollision) {
                    shownLabels.push(candidate);
                    visibleLabelIndices.add(candidate.index);
                }
            }
        }

        function shouldShowLabel(index) {
            return visibleLabelIndices.has(index);
        }

        function createCompassChart() {
            const canvas = document.getElementById('compassChart');
            const ctx = canvas.getContext('2d');

            let allData = [
                ...processedData.dinner,
                ...processedData.workplace,
                ...processedData.podcast
            ];

            const minAgi = 1;
            const maxAgi = 5;
            const minSafety = 1;
            const maxSafety = 5;

            calculateVisibleLabels(allData);

            const dataset = {
                label: 'Researchers',
                data: allData.map(d => ({
                    x: d.agi,
                    y: d.invertedSafety,
                    label: d.label,
                    count: d.count,
                    agi: d.agi,
                    safety: d.safety
                })),
                backgroundColor: allData.map(d => getColorForPoint(d.agi, d.safety)),
                borderColor: allData.map(d => getBorderColorForPoint(d.agi, d.safety)),
                borderWidth: 1.5,
                pointRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverRadius: allData.map(d => Math.max(4, Math.sqrt(d.count) * 1.2)),
                pointHoverBackgroundColor: allData.map(d => getHoverColorForPoint(d.agi, d.safety)),
                pointHoverBorderColor: allData.map(d => getBorderColorForPoint(d.agi, d.safety)),
                pointHoverBorderWidth: 2.5,
            };

            new Chart(ctx, {
                type: 'scatter',
                data: { datasets: [dataset] },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        `${point.label}`,
                                        `AGI Timeline: ${point.agi.toFixed(2)}/5`,
                                        `Safety Priority: ${point.safety.toFixed(2)}/5`,
                                        `Responses: ${point.count}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                return context.hovered || shouldShowLabel(context.dataIndex);
                            },
                            align: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                const midX = (minAgi + maxAgi) / 2;
                                const midY = (minSafety + maxSafety) / 2;

                                if (point.x > midX && point.y < midY) return 'right';
                                if (point.x < midX && point.y < midY) return 'left';
                                if (point.x > midX && point.y > midY) return 'right';
                                return 'left';
                            },
                            offset: 6,
                            color: '#000',
                            font: {
                                size: 9,
                                weight: '600',
                                family: 'Arial, sans-serif'
                            },
                            formatter: function(value) {
                                const label = value.label;
                                return label.length > 18 ? label.substring(0, 16) + '...' : label;
                            },
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: function(context) {
                                return context.hovered ? '#000' : '#999';
                            },
                            borderWidth: 1,
                            borderRadius: 3,
                            padding: 4
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'AGI Likely Within 10 Years →',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minAgi,
                            max: maxAgi,
                            ticks: {
                                stepSize: 1
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '← Prioritize AI Safety (Inverted)',
                                font: { size: 12, weight: 'bold', family: 'Times New Roman' }
                            },
                            min: minSafety,
                            max: maxSafety,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    return 6 - value;
                                }
                            },
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 3 ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: function(context) {
                                    return context.tick.value === 3 ? 2 : 1;
                                }
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function createVisualizations(data) {
            data = data.filter(row => row.Timestamp && row.Timestamp.trim() !== '');

            document.getElementById('totalResponses').textContent = data.length;

            const agiCol = 'I believe AGI is likely within the next 10 years.';
            const safetyCol = 'We should slow down AI progress until safety is better understood.';

            const agiValues = data.map(d => parseFloat(d[agiCol])).filter(v => !isNaN(v));
            const safetyValues = data.map(d => parseFloat(d[safetyCol])).filter(v => !isNaN(v));

            const agiAvg = (agiValues.reduce((a, b) => a + b, 0) / agiValues.length).toFixed(2);
            const safetyAvg = (safetyValues.reduce((a, b) => a + b, 0) / safetyValues.length).toFixed(2);

            document.getElementById('agiAvg').textContent = agiAvg + '/5';
            document.getElementById('safetyAvg').textContent = safetyAvg + '/5';

            const workplaceCounts = countValues(data, 'I would most want to work at:');
            const topWorkplace = Object.keys(workplaceCounts).sort((a, b) => workplaceCounts[b] - workplaceCounts[a])[0];
            document.getElementById('topWorkplace').textContent = topWorkplace;

            createInsights(data, workplaceCounts, agiAvg, safetyAvg);

            createDinnerChart(data);
            createAGIChart(data);
            createWorkplaceChart(data);
            createResearchStyleChart(data);
            createTrainingStyleChart(data);
            createSafetyChart(data);
            createPodcastChart(data);
            createBottleneckChart(data);
        }

        function countValues(data, column) {
            const counts = {};
            data.forEach(row => {
                const value = row[column];
                if (value && value.trim() !== '') {
                    counts[value] = (counts[value] || 0) + 1;
                }
            });
            return counts;
        }

        function getTopN(counts, n) {
            return Object.entries(counts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, n);
        }

        function createInsights(data, workplaceCounts, agiAvg, safetyAvg) {
            const dinnerCounts = countValues(data, 'Who would you most want to have dinner with?');
            const topDinner = getTopN(dinnerCounts, 1)[0];

            const statementCounts = countValues(data, 'Which statement do you most agree with?');
            const topStatement = getTopN(statementCounts, 1)[0];

            const insights = [
                `<strong>${topDinner[0]}</strong> is the most desired dinner companion with ${topDinner[1]} votes`,
                `Most agreed statement: "<strong>${topStatement[0]}</strong>" (${topStatement[1]} votes)`,
                `Average AGI belief is ${agiAvg}/5 - moderate skepticism about AGI within 10 years`,
                `AI safety concern averages ${safetyAvg}/5`,
                `<strong>${Object.entries(workplaceCounts).sort((a,b) => b[1] - a[1])[0][0]}</strong> is the most preferred workplace`
            ];

            document.getElementById('insightsList').innerHTML = insights.map(i => `<li>${i}</li>`).join('');
        }

        function createDinnerChart(data) {
            const counts = countValues(data, 'Who would you most want to have dinner with?');
            const top10 = getTopN(counts, 10);

            new Chart(document.getElementById('dinnerChart'), {
                type: 'bar',
                data: {
                    labels: top10.map(d => d[0]),
                    datasets: [{
                        label: 'Votes',
                        data: top10.map(d => d[1]),
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function createAGIChart(data) {
            const column = 'I believe AGI is likely within the next 10 years.';
            const values = data.map(d => parseFloat(d[column])).filter(v => !isNaN(v));
            const distribution = [1, 2, 3, 4, 5].map(rating =>
                values.filter(v => v === rating).length
            );

            new Chart(document.getElementById('agiChart'), {
                type: 'bar',
                data: {
                    labels: ['1 (Unlikely)', '2', '3', '4', '5 (Very Likely)'],
                    datasets: [{
                        label: 'Responses',
                        data: distribution,
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function createWorkplaceChart(data) {
            const counts = countValues(data, 'I would most want to work at:');
            const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            new Chart(document.getElementById('workplaceChart'), {
                type: 'bar',
                data: {
                    labels: entries.map(d => d[0]),
                    datasets: [{
                        label: 'Preferences',
                        data: entries.map(d => d[1]),
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function createResearchStyleChart(data) {
            const counts = countValues(data, 'Your research style is most like:');
            const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            new Chart(document.getElementById('researchStyleChart'), {
                type: 'doughnut',
                data: {
                    labels: entries.map(d => d[0]),
                    datasets: [{
                        data: entries.map(d => d[1]),
                        backgroundColor: [
                            'rgba(0, 0, 0, 0.9)',
                            'rgba(0, 0, 0, 0.7)',
                            'rgba(0, 0, 0, 0.5)',
                            'rgba(100, 100, 100, 0.7)',
                            'rgba(150, 150, 150, 0.7)',
                            'rgba(200, 200, 200, 0.7)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true
                }
            });
        }

        function createTrainingStyleChart(data) {
            const counts = countValues(data, 'Your model training style is closest to:');
            const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            new Chart(document.getElementById('trainingStyleChart'), {
                type: 'bar',
                data: {
                    labels: entries.map(d => d[0]),
                    datasets: [{
                        label: 'Count',
                        data: entries.map(d => d[1]),
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function createSafetyChart(data) {
            const column = 'We should slow down AI progress until safety is better understood.';
            const values = data.map(d => parseFloat(d[column])).filter(v => !isNaN(v));
            const distribution = [1, 2, 3, 4, 5].map(rating =>
                values.filter(v => v === rating).length
            );

            new Chart(document.getElementById('safetyChart'), {
                type: 'bar',
                data: {
                    labels: ['1 (No)', '2', '3', '4', '5 (Yes)'],
                    datasets: [{
                        label: 'Responses',
                        data: distribution,
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function createPodcastChart(data) {
            const counts = countValues(data, 'What is your favorite ML related podcast?');
            const top8 = getTopN(counts, 8);

            new Chart(document.getElementById('podcastChart'), {
                type: 'bar',
                data: {
                    labels: top8.map(d => d[0]),
                    datasets: [{
                        label: 'Listeners',
                        data: top8.map(d => d[1]),
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        function createBottleneckChart(data) {
            const counts = countValues(data, 'What is the primary bottleneck right now?');
            const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            new Chart(document.getElementById('bottleneckChart'), {
                type: 'bar',
                data: {
                    labels: entries.map(d => d[0]),
                    datasets: [{
                        label: 'Responses',
                        data: entries.map(d => d[1]),
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
    </script>
</body>
</html>
